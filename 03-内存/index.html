<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="ChengShuomin"><title>内存 | 学习笔记</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script class="keep-theme-configurations">const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-cn"}
    KEEP.theme_config = {"base_info":{"primary_color":"#d5c4f2","title":"学习笔记","author":"ChengShuomin","avatar":"/images/avatar.webp","logo":"/images/logo.svg","favicon":"/images/favicon.webp"},"language":"zh-CN","menu":{"home":"/","archives":"/archives"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"♚ 今天不走，明天要跑 ♚ || 走过的路，每一步都算数","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":true,"percent":true,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD","copyright_info":true,"share":true,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.39"},"waline":{"server_url":null,"reaction":false,"version":"3.3.2"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2021,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}</script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left flex-start border-box"><a class="logo-image border-box" href="/"><img src="/images/logo.svg"> </a><a class="site-name border-box" href="/">学习笔记</a></div><div class="right border-box"><div class="pc border-box"><ul class="menu-list border-box"><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/">首页</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/archives">归档</a></li></ul></div><div class="mobile border-box flex-start"><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list border-box"><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/">首页</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">归档</a></label></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-bottom border-box"><div class="post-title">内存</div><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/avatar.webp"></div><div class="info-box"><div class="author border-box"><span class="name">ChengShuomin</span> <span class="author-badge">Lv3</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class="datetime">2022-01-08</span> </span><span class="post-tag meta-info-item border-box"><ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/JavaScript/">JavaScript</a></li></ul></span></div></div></div></div></div><div class="post-content keep-markdown-body"><h1 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1. 内存模型"></a>1. 内存模型</h1><p>内存空间分为 **栈(stack)、堆(heap)、池(一般也会归类为栈中)**。</p><p>其中<strong>栈</strong>存放变量，<strong>堆</strong>存放复杂对象，<strong>池</strong>存放常量。</p><h3 id="1-1-栈内存"><a href="#1-1-栈内存" class="headerlink" title="1.1 栈内存"></a>1.1 栈内存</h3><p>栈是一种特殊的列表。</p><p>存取：<strong>先进后出</strong></p><p>存储基本数据类型： <strong><code>String</code>、<code>Number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>Symbol</code></strong></p><p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。</p><h3 id="1-2-堆内存"><a href="#1-2-堆内存" class="headerlink" title="1.2 堆内存"></a>1.2 堆内存</h3><p>堆是一种经过排序的树形数据结构，每个结点都有一个值。</p><p>堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。 由于堆的这个特性，常用来实现优先队列。</p><p>存取：<strong>随意</strong></p><p>存储引用数据类型：<code>Object</code>、<code>Array</code>、<code>Function</code>等</p><p>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； <strong>引用数据类型在栈中存储了指针</strong>，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，<strong>取得地址后从堆中获得值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// 变量 a 存在栈中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 b 存在栈中，b的值是&#123;age: 18&#125;的引用地址；&#123;age: 18&#125;作为对象存在堆内存</span></span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;; </span><br></pre></td></tr></table></figure><h4 id="1-2-1-为什么可以改变-const-的值？"><a href="#1-2-1-为什么可以改变-const-的值？" class="headerlink" title="1.2.1 为什么可以改变 const 的值？"></a>1.2.1 为什么可以改变 const 的值？</h4><p>ES6语法中的 const 声明一个只读的常量。一旦声明，常量的值就不能改变。但是下面的代码可以改变 const 的值，这是为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span> <span class="comment">// 123; // 可以修改const，不报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><p>因为const foo存的{}的地址，当foo直接改变地址时，就违反了改变的原则；而当{}中增加属性值时，foo的引用地址没改变，所以可以修改。</p><h3 id="1-3-简单类型和复杂类型的区别"><a href="#1-3-简单类型和复杂类型的区别" class="headerlink" title="1.3 简单类型和复杂类型的区别"></a>1.3 简单类型和复杂类型的区别</h3><ul><li><p>声明变量时不同的内存地址分配：</p></li><li><ul><li>简单类型的值存放在栈中，在栈中存放的是对应的值</li><li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li></ul></li><li><p>不同的类型数据导致赋值变量时的不同：</p></li><li><ul><li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li><li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li></ul></li></ul><h2 id="2-内存的生命周期："><a href="#2-内存的生命周期：" class="headerlink" title="2. 内存的生命周期："></a>2. 内存的生命周期：</h2><p><img src="/03-%E5%86%85%E5%AD%98/1661853741029-c26d1a6a-79ca-4f67-a7a6-30c667a149af-20220901232511827.png" alt="img"></p><ol><li>分配需要的内存</li></ol><p>JavaScript 在定义变量或者创建一个变量的时候，就完成了内存分配。</p><ol><li>使用分配到的内存（读、写操作）</li><li>不需要时将其释放、归还</li></ol><p>“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。</p><h2 id="3-垃圾回收机制（GC）"><a href="#3-垃圾回收机制（GC）" class="headerlink" title="3. 垃圾回收机制（GC）"></a>3. 垃圾回收机制（GC）</h2><p><strong>Java garbage collection (GC)</strong></p><h3 id="3-1-JavaScript-的自动垃圾收集机制"><a href="#3-1-JavaScript-的自动垃圾收集机制" class="headerlink" title="3.1 JavaScript 的自动垃圾收集机制"></a>3.1 JavaScript 的自动垃圾收集机制</h3><p>就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此 a &#x3D; null 其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。</p><h4 id="3-1-1-如何判断一个变量已经死了？"><a href="#3-1-1-如何判断一个变量已经死了？" class="headerlink" title="3.1.1 如何判断一个变量已经死了？"></a>3.1.1 如何判断一个变量已经死了？</h4><p>一个对象在已经没有引用时。</p><p>全局变量：会到程序执行完毕，才会被回收；</p><p>局部变量：函数执行结束后，如果有外部引用，则不能被回收；没有便可以被回收；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= &#123;<span class="attr">a</span>: <span class="number">123</span>&#125; <span class="comment">//  &#123;a: 123&#125; 有a引用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> b1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> c =&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> b1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">b</span>();<span class="comment">//如果return b1,则b1会被回收；如果return c，c不会被回收；</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-到底什么时候回收？"><a href="#3-1-2-到底什么时候回收？" class="headerlink" title="3.1.2 到底什么时候回收？"></a>3.1.2 到底什么时候回收？</h4><p>JavaScript 是自动回收机制，以下是可能会触发的情况：</p><ul><li>执行完一次主线程（或宏任务、微任务），就会回收一次</li><li>当内存不够时，一次执行中可能也会触发回收</li></ul><h4><a href="#" class="headerlink"></a></h4><h3 id="3-2-引用计数算法"><a href="#3-2-引用计数算法" class="headerlink" title="3.2 引用计数算法"></a>3.2 引用计数算法</h3><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象person，有两个指向属性age和name的引用</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="literal">null</span>; <span class="comment">// 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = person; </span><br><span class="line">person = <span class="number">1</span>;         <span class="comment">//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收</span></span><br><span class="line"></span><br><span class="line">p = <span class="literal">null</span>;           <span class="comment">//原person对象已经没有引用，很快会被回收</span></span><br></pre></td></tr></table></figure><h4 id="限制：循环引用会导致内存泄露"><a href="#限制：循环引用会导致内存泄露" class="headerlink" title="限制：循环引用会导致内存泄露"></a>限制：循环引用会导致内存泄露</h4><p>循环引用：两个对象相互引用，尽管它们不再使用，也不会进行回收，导致内存泄露。</p><p>该算法有个限制：无法处理循环引用的事例。在下面的例子1中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p><ul><li>案例1：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.<span class="property">a</span> = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.<span class="property">a</span> = o; <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;azerty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><ul><li>案例2：</li></ul><p>如：创建一个DOM元素并绑定一个点击事件，变量div有事件处理函数的引用，同时事件处理函数也有div的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDivElement&quot;</span>);</span><br><span class="line">  div.<span class="property">circularReference</span> = div;</span><br><span class="line">  div.<span class="property">lotsOfData</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。</p><h3 id="3-3-标记清除算法"><a href="#3-3-标记清除算法" class="headerlink" title="3.3 标记清除算法"></a>3.3 标记清除算法</h3><p>从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。</p><p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>简单说，将那些无法由根部触触发到的对象标记为不再使用，稍后进行回收。</p><p><strong>此算法避免内存泄露的方法：</strong></p><p><strong>明确切断需要回收的对象与根部的联系</strong></p><h4 id="限制：那些无法从根对象查询到的对象都将被清除"><a href="#限制：那些无法从根对象查询到的对象都将被清除" class="headerlink" title="限制：那些无法从根对象查询到的对象都将被清除"></a>限制：那些无法从根对象查询到的对象都将被清除</h4><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p><h3 id="3-4-V8引擎"><a href="#3-4-V8引擎" class="headerlink" title="3.4 V8引擎"></a>3.4 V8引擎</h3><h4 id="3-4-1-堆内存大小"><a href="#3-4-1-堆内存大小" class="headerlink" title="3.4.1 堆内存大小"></a>3.4.1 堆内存大小</h4><p>在V8引擎的堆内存的大小上限在64位系统中为 <strong>1464MB</strong>，在32位系统中则为 <strong>732MB</strong>（在node 环境有 C++ 加持下，会略扩容）</p><h4 id="3-4-2-堆内存对象的分代管理"><a href="#3-4-2-堆内存对象的分代管理" class="headerlink" title="3.4.2 堆内存对象的分代管理"></a>3.4.2 堆内存对象的分代管理</h4><p>V8引擎对堆内存中的 JavaScript 对象进行分代管理。</p><p><img src="/03-%E5%86%85%E5%AD%98/1662016839861-073ba972-8ecb-40e9-b3eb-8a8fd7e42379-20220901232511902.png" alt="img"></p><p>“垃圾变量”：不再使用的变量或没有被引用的对象。</p><h5 id="3-4-2-1-新生代："><a href="#3-4-2-1-新生代：" class="headerlink" title="3.4.2.1 新生代："></a>3.4.2.1 新生代：</h5><p>短时间存活的新变量会存在新生代中，新生代的内存量极小。在 64位系统下，约32M。</p><p><strong>新生代的回收算法:</strong></p><p>新生代空间一分为二，分为 from: 16M、to: 16M(一直空的) 区。</p><p><strong>核心：复制 - 清空</strong></p><p><strong>过程：</strong></p><p>删掉垃圾变量，把from存活的变量复制到to，把from清空，再把to和from的名字对调。</p><p><strong>优势：</strong></p><p>这样可以提升回收速度，时间复杂度低，牺牲空间换时间。不用像老生代那样整理磁盘。</p><h5 id="3-4-2-2-老生代："><a href="#3-4-2-2-老生代：" class="headerlink" title="3.4.2.2 老生代："></a>3.4.2.2 老生代：</h5><p>生存时间比较长的变量，会转存到老生代，老生代占据了几乎所有内存。在 64位系统下，约1.4G。</p><p><strong>老生代回收算法：</strong></p><ol><li><p>标记垃圾变量</p></li><li><p>清除垃圾变量</p></li><li><p>整理磁盘（）–</p></li><li><ol><li>为什么要整理磁盘？</li></ol></li></ol><p>如果清除的垃圾变量是多个不连续的变量，虽然空间够，但如果要存一个数组，而<strong>数组存储，必须是在连续的内存空间</strong>，多个不连续的空白空间不能存储数组。</p><ol><li><ol><li>如何整理磁盘？</li></ol></li></ol><p>把空出来的内存位置移动合并，留最后整个统一的空白块</p><h5 id="3-4-2-3-新生代什么时候转换到老生代？"><a href="#3-4-2-3-新生代什么时候转换到老生代？" class="headerlink" title="3.4.2.3  新生代什么时候转换到老生代？"></a>3.4.2.3 <strong>新生代什么时候转换到老生代？</strong></h5><ol><li>新生代发现本次复制（from-&gt; to复制）后，会占用超过25%的to空间</li><li>这个对象已经在新生代经历过一次回收</li></ol><p>就会将新生代变量放到老生代。</p><h3 id="3-4-3-为什么-JavaScript-要限制内存，设置-1-4G？"><a href="#3-4-3-为什么-JavaScript-要限制内存，设置-1-4G？" class="headerlink" title="3.4.3 为什么 JavaScript 要限制内存，设置 1.4G？"></a>3.4.3 为什么 JavaScript 要限制内存，设置 1.4G？</h3><ol><li>JavaScript 是脚本语言，而脚本语言的特性是一次执行的，没必要弄太大；</li></ol><p>而Java 这类是后端语言，是作为服务的，会一直开着运行，也就会不断增加内存。</p><ol><li><strong>核心原因：</strong>垃圾回收是阻塞式的（阻塞式是如果要进行垃圾回收，会中断代码执行，而 JavaScript 是单线程的）</li></ol><p>而进行一次 1.4G 的垃圾回收，大约需要1s。</p><p>如果垃圾太大，垃圾回收耗时久，用户直观看页面感知非常明显；但后端如果中断1s相对影响不大。</p><h2 id="4-检测内存"><a href="#4-检测内存" class="headerlink" title="4. 检测内存"></a>4. 检测内存</h2><h3 id="4-1-浏览器端"><a href="#4-1-浏览器端" class="headerlink" title="4.1 浏览器端"></a>4.1 浏览器端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.performance.memory</span><br></pre></td></tr></table></figure><p>在 DevTools 中，使用 Memory 工具。</p><h4 id="Shallow-Size："><a href="#Shallow-Size：" class="headerlink" title="Shallow Size："></a>Shallow Size：</h4><p>对象本身占用<a class="link" target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存<i class="fas fa-external-link-alt"></i></a>的大小，不包含其引用的对象。</p><ul><li>常规对象（非数组）的 Shallow size 由其成员变量的数量和类型决定。</li><li>数组的shallow size由数组元素的类型及数组长度决定</li></ul><h4 id="Retained-Size："><a href="#Retained-Size：" class="headerlink" title="Retained Size："></a>Retained Size：</h4><p>对象的Retained Size &#x3D; 对象本身的Shallow Size + 对象能直接或间接访问到的对象的Shallow Size</p><h4 id="Heap-Size"><a href="#Heap-Size" class="headerlink" title="Heap Size:"></a>Heap Size:</h4><p>堆的大小，当资源增加，当前堆的空间不够时，系统会增加堆的大小，若超过上限（如64M，阈值视平台而定）则会被杀掉 。</p><h4 id="Allocated"><a href="#Allocated" class="headerlink" title="Allocated:"></a>Allocated:</h4><p>堆中已分配的大小，即 App 应用实际占用的内存大小，资源回收后，此项数据会变小。</p><h3 id="4-2-Node-端"><a href="#4-2-Node-端" class="headerlink" title="4.2 Node 端"></a>4.2 Node 端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已使用的内存</span></span><br><span class="line">process.<span class="title function_">memoryUsage</span>()</span><br></pre></td></tr></table></figure><ul><li><p>Node端可以手动触发垃圾回收：global.gc （因为其源码是C++）</p></li><li><p>Node端可以设置内存：</p></li></ul><p>Node 新版是可以自动扩，如下将内存设置到最大：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 test.js 文件，设置最大的老生代空间为1700M</span></span><br><span class="line">node --max-old-space-size=<span class="number">1700</span> test.<span class="property">js</span> <span class="comment">// 单位是MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 test.js 文件，设置最大的新生代空间为1024M</span></span><br><span class="line">node --max_semi_space_size=<span class="number">1024</span> test.<span class="property">js</span> <span class="comment">// 单位是KB</span></span><br></pre></td></tr></table></figure><h2 id="5-优化内存"><a href="#5-优化内存" class="headerlink" title="5. 优化内存"></a>5. 优化内存</h2><ul><li>少定义全局变量；</li><li>如果一定要定义全局变量，可以用完后，手动释放掉，如 <code>a=undefined;a=null;</code> (原理：将引用类型赋值为基本类型，去引用)；</li><li>注意增长闭包情况；</li></ul><h3 id="5-1-增长闭包："><a href="#5-1-增长闭包：" class="headerlink" title="5.1 增长闭包："></a>5.1 增长闭包：</h3><p>普通闭包，对象数据量不大，对整个项目一般影响不大，但需注意增长闭包。</p><p>如下例子，是会无限增长的闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="title function_">funciotn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span>&gt;<span class="number">0</span>)&#123; <span class="comment">//可通过限制条数，规避对内存的影响</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="6-WeakMap"><a href="#6-WeakMap" class="headerlink" title="6. WeakMap"></a>6. WeakMap</h2><p>ES6 推出了两种新的数据结构：<strong>WeakSet</strong> 和 <strong>WeakMap</strong>。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是<strong>弱引用</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.<span class="title function_">get</span>(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><p>参考：</p><p><a class="link" target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://juejin.cn/post/6844903615300108302">https://juejin.cn/post/6844903615300108302<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://www.imooc.com/article/13489">https://www.imooc.com/article/13489<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info-container border-box"><div class="copyright-info-content border-box"><div class="copyright-info-top border-box"><div class="copyright-post-title border-box text-ellipsis">内存</div><div class="copyright-post-link border-box text-ellipsis">03-内存/</div></div><div class="copyright-info-bottom border-box"><div class="copyright-post-author bottom-item"><div class="type">作者</div><div class="content">ChengShuomin</div></div><div class="post-time bottom-item"><div class="type">发布于</div><div class="content">2022-01-08</div></div><div class="post-license bottom-item"><div class="type">许可</div><div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank"><i class="fa-brands fa-creative-commons"></i> <i class="fa-brands fa-creative-commons-by"></i> <i class="fa-brands fa-creative-commons-nc"></i> <i class="fa-brands fa-creative-commons-sa"></i></a></div></div></div><i class="copyright-bg fa-solid fa-copyright"></i></div><div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/JavaScript/">JavaScript</a></li></ul></div><div><div class="post-share-container border-box"><ul class="share-list-wrap border-box"><li class="qq share-item border-box flex-center tooltip" data-tooltip-content="分享到 QQ"><i class="fa-brands fa-qq"></i></li><li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content="分享到微信" data-tooltip-img-tip="微信扫一扫" data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"><i class="fa-brands fa-weixin"></i></li><li class="weibo share-item border-box flex-center tooltip" data-tooltip-content="分享到微博"><i class="fa-brands fa-weibo"></i></li></ul></div></div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/101-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%85%A5%E5%8F%A3/" title="1. 源码学习入口"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">1. 源码学习入口</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/06-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95vs%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95vs%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/" title="静态方法vs实例方法vs原型方法"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">静态方法vs实例方法vs原型方法</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="copyright-info info-item">&copy;&nbsp;<span>2021</span>&nbsp;-&nbsp;2025 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">ChengShuomin</a></div><div class="theme-info info-item">由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="post-tools-list border-box"><li class="tools-item flex-center full-screen"><i class="fa-solid fa-expand"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div></main><script src="/js/utils.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/toggle-theme.js"></script><script src="/js/code-block.js"></script><script src="/js/main.js"></script><script src="/js/libs/anime.min.js"></script><div><script src="/js/post/post-helper.js"></script><script src="/js/post/copyright-info.js"></script><script src="/js/post/share.js"></script></div></body></html>