<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="chengshuomin"><title>学习笔记</title><meta name="description" content="chengshuomin blog"><meta name="keywords" content="Blog,博客,chengshuomin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon1.svg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/title.svg" style="width:200px;" alt="favicon"><h3 title=""><a href="/">学习笔记</a></h3><div class="description"><p>chengshuomin blog</p></div></div><ul class="social-links"></ul></div></div><div class="footer"><div class="p"><span> 全站 CC-BY-SA-3.0</span><i class="fa fa-star"></i><span> chengshuomin</span></div><div class="by_farbox"><span>Powered by</span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a><span> &</span><span>Anatolo</span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/401-Promise/">Promise</a></h3></div><div class="post-content"><div class="card"><p><h2 id="1-Promise-对象"><a href="#1-Promise-对象" class="headerlink" title="1. Promise 对象"></a>1. Promise 对象</h2><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<ul>
<li>Promise 构造函数接受 <strong>一个函数</strong> 作为参数。</li>
<li>该函数的两个参数分别是resolve和reject，它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Promise-对象实例结构"><a href="#1-1-Promise-对象实例结构" class="headerlink" title="1.1 Promise 对象实例结构"></a>1.1 Promise 对象实例结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/401-Promise/1660893766690-7a5ae28b-54c5-40a1-870f-058820822104-20220820215141535.png" alt="img"></p>
<ul>
<li>Promise 的内部属性有 <code>PromiseState``PromiseResult</code></li>
<li>实例 promise 的 <code>__proto__</code>指向 Promise 的原型对象，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype == promise.__proto__` 为 `true</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise 原型方法有： then、catch、finally</li>
<li>Promise 构造函数方法有：all、allSettled、any、race、resolve、reject。</li>
</ul>
<h3 id="1-2-状态"><a href="#1-2-状态" class="headerlink" title="1.2 状态"></a>1.2 状态</h3><ul>
<li><p>Promise对象代表一个异步操作，有三种状态：</p>
</li>
<li><ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
</li>
<li><p><strong>只有异步操作的结果，可以决定当前是哪一种状态</strong>，任何其他操作都无法改变这个状态。改变的情况只有：</p>
</li>
<li><ul>
<li>从pending变为fulfilled</li>
<li>从pending变为rejected</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise3&#x27;</span>);</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/401-Promise/1660892604893-7c3b163d-dc7a-467c-b84c-706353c537f9-20220820215141659.png" alt="img"></p>
<p><img src="/401-Promise/1660897204141-977c9093-639b-42c1-9d6b-185f3b5688ee-20220820215141707.png" alt="img"></p>
<h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><ul>
<li><p>Promise 是微任务。</p>
</li>
<li><p><strong>Promise 新建后就会立即执行。</strong></p>
</li>
<li><p>调用resolve或reject并不会终结 Promise 的参数函数的执行，即 <strong>resolve</strong><strong>(<strong><strong>‘success’</strong></strong>) 后的语句仍执行；</strong>但<code>return **resolve**(&#39;success&#39;) </code>加上 return 语句后，后面的语句就不执行了。</p>
</li>
<li><p>没有 <strong>resolve</strong> 或 reject ，promise.then 并不会执行。</p>
</li>
<li><p><code>console.**log**(&#39;1&#39;, new Promise(...)); </code> 先执行 new Promise 构造函数的代码，再执行 console.log。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<h3 id="1-4-Promise-嵌套"><a href="#1-4-Promise-嵌套" class="headerlink" title="1.4 Promise 嵌套"></a>1.4 Promise 嵌套</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1&#x27;</span>, p1)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 a&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 b&#x27;</span>, p2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result, <span class="string">&#x27;p2&#x27;</span>, p2, <span class="string">&#x27;p1&#x27;</span>, p1))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error, <span class="string">&#x27;p2&#x27;</span>, p2, <span class="string">&#x27;p1&#x27;</span>, p1))</span><br></pre></td></tr></table></figure>

<p><img src="/401-Promise/1660880665692-b28328a0-02da-4fd0-b738-cdc568df15c3-20220820215141694.png" alt="img"></p>
<p>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时p1的状态就会传递给p2，也就是说<strong>，<strong><strong>p1</strong></strong>的状态决定了<strong><strong>p2</strong></strong>的状态</strong>。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变<strong>；如果<strong><strong>p1</strong></strong>的状态已经是<strong><strong>resolved</strong></strong>或者<strong><strong>rejected</strong></strong>，那么<strong><strong>p2</strong></strong>的回调函数将会立刻执行。</strong></p>
<h2 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2. 原型方法"></a>2. 原型方法</h2><h3 id="2-1-Promise-prototype-then-onFulfilled-onRejected"><a href="#2-1-Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="2.1 Promise.prototype.then(onFulfilled[, onRejected])"></a>2.1 <code>Promise.prototype.then(onFulfilled[, onRejected])</code></h3><p>onFulfilled : resolved状态的回调<strong>函数</strong></p>
<p>onRejected ：rejected状态的回调<strong>函数</strong></p>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>then() 返回一个<strong>新的</strong> Promise 实例，这就是 Promise 可以链式调用的原因</p>
<h3 id="2-2-Promise-prototype-catch"><a href="#2-2-Promise-prototype-catch" class="headerlink" title="2.2 Promise.prototype.catch()"></a>2.2 Promise.prototype.catch()</h3><p>是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<ul>
<li>若 .then(null, rejection) 指定和 .catch() 都存在，则执行先出现的。</li>
<li>如果将 .catch 放在 .then 前，要是then()方法里面报错，就与前面的catch()无关了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseErr = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promiseErr.<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;&#125;, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>,err)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch&#x27;</span>,error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// reject Error: test</span></span><br><span class="line"></span><br><span class="line">promiseErr.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch&#x27;</span>,error);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;&#125;, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>,err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// catch Error: test</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Promise-prototype-finally"><a href="#2-3-Promise-prototype-finally" class="headerlink" title="2.3 Promise.prototype.finally()"></a>2.3 Promise.prototype.finally()</h3><ul>
<li>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</li>
<li>不依赖于 Promise 的执行结果。</li>
<li>写在前面就会先执行（仍是微任务）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseFin = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promiseFin.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// finally </span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>

<h2 id="3-构造函数方法"><a href="#3-构造函数方法" class="headerlink" title="3. 构造函数方法"></a>3. 构造函数方法</h2><h3 id="3-1-Promise-resolve"><a href="#3-1-Promise-resolve" class="headerlink" title="3.1 Promise.resolve()"></a>3.1 <code>Promise.resolve()</code></h3><p>将现有对象转为 Promise 对象，</p>
<p>**Promise.resolve(value)**方法返回一个以给定值解析后的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  <span class="comment">// expected output: 123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Promise-reject"><a href="#3-2-Promise-reject" class="headerlink" title="3.2 Promise.reject()"></a>3.2 <code>Promise.reject()</code></h3><p>将现有对象转为 Promise 对象，</p>
<p><strong>Promise.reject()</strong> 方法返回一个带有拒绝原因的 Promise 对象。</p>
<h3 id="3-3-Promise-all-p1-p2-p3"><a href="#3-3-Promise-all-p1-p2-p3" class="headerlink" title="3.3**Promise.all([ p1, p2, p3, ...])**"></a>3.3<code>**Promise.all([ p1, p2, p3, ...])**</code></h3><p>【<strong>只要有 rejected，状态都变为 rejected</strong>】</p>
<p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<strong>只要有一个 rejected，状态都变为 rejected。</strong></p>
<ul>
<li><strong>只有<strong><strong>p1</strong></strong>、<strong><strong>p2</strong></strong>、<strong><strong>p3</strong></strong>的状态都变成<strong><strong>fulfilled</strong></strong>，<strong><strong>p</strong></strong>的状态才会变成****fulfilled</strong>，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello p1&#x27;</span>);<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello p2&#x27;</span>);<span class="title function_">resolve</span>(<span class="string">&#x27;hellooo&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2])</span><br></pre></td></tr></table></figure>

<p><img src="/401-Promise/1660922627729-ba17d6d2-6c89-4665-8d13-d3efb4096c4e-20220820215141624.png" alt="img"></p>
<ul>
<li>只要p1、p2、p3之中有<strong>一个被<strong><strong>rejected</strong></strong>，<strong><strong>p</strong></strong>的状态就变成****rejected</strong>，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ul>
<p>Promise.all() 是所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello p1&#x27;</span>);<span class="title function_">reject</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello p2&#x27;</span>);<span class="title function_">resolve</span>(<span class="string">&#x27;hellooo&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2])</span><br></pre></td></tr></table></figure>

<p><img src="/401-Promise/1660922685690-53c90451-c4db-4748-ae8b-8778185918fe-20220820215141687.png" alt="img"></p>
<h3 id="3-4-Promise-allSettled"><a href="#3-4-Promise-allSettled" class="headerlink" title="3.4 Promise.allSettled()"></a>3.4 <code>Promise.allSettled()</code></h3><p>【用来确定一组异步操作是否都结束了（不管成功或失败）】</p>
<p>同上的例子，用 Promise.all()  返回的状态是 reject；</p>
<p>用  Promise.allSettled()  返回的状态是 fulfilled；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello p1&#x27;</span>);<span class="title function_">reject</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello p2&#x27;</span>);<span class="title function_">resolve</span>(<span class="string">&#x27;hellooo&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1,p2])</span><br></pre></td></tr></table></figure>

<p><img src="/401-Promise/1660923528734-33457f9f-aaf7-4c48-96a9-9337b7306b89-20220820215141680.png" alt="img"></p>
<h3 id="3-5-Promise-race"><a href="#3-5-Promise-race" class="headerlink" title="3.5 Promise.race()"></a>3.5 <code>Promise.race()</code></h3><p>【取率先改变的状态】</p>
<p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<p>只要p1、p2、p3之中有一个实例<strong>率先改变</strong>状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h3 id="3-6-Promise-any"><a href="#3-6-Promise-any" class="headerlink" title="3.6 Promise.any() "></a>3.6 <code>Promise.any() </code></h3><p>【任意一个成功就算成功，全部失败才是失败】</p>
<p>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p>
<p>想要刷題可看这个：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904077537574919">https://juejin.cn/post/6844904077537574919</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise">https://es6.ruanyifeng.com/#docs/promise</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-10-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ES6/" title="ES6">ES6 </a><span class="leancloud_visitors"></span><span>大约1676个字, 5分钟35秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/302-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">正向代理与反向代理</a></h3></div><div class="post-content"><div class="card"><p><p><img src="/302-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/1658237934758-62135c80-5ead-42bf-aa8b-f86c770e6697.png" alt="img"></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>正向代理</strong></th>
<th><strong>反向代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td>代理目标</td>
<td><strong>“代理服务器”代理了”客户端”，去和”目标服务器”进行交互</strong></td>
<td><strong>“代理服务器”代理了”目标服务器”，去和”客户端”进行交互</strong></td>
</tr>
<tr>
<td>访问目标服务器时</td>
<td>目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理</td>
<td>客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理</td>
</tr>
<tr>
<td></td>
<td>代理服务器 帮助 客户端 请求页面并缓存，再返回给 客户端</td>
<td>代理服务器 将 目标服务器 请求结果缓存到本地，再返回给 客户端</td>
</tr>
<tr>
<td></td>
<td>客户端 使用 代理服务器的 IP 和端口去浏览器访问</td>
<td>服务端 使用 代理服务器的 IP 和端口给 客户端 使用</td>
</tr>
</tbody></table>
<h2 id="正向代理-（forward-proxy）"><a href="#正向代理-（forward-proxy）" class="headerlink" title="正向代理 （forward proxy）"></a>正向代理 （forward proxy）</h2><p>为了从 <code>目标服务器</code> 获取内容，<code>客户端</code> 向 <code>代理服务器</code> 发送一个请求并指定目标，然后 <code>代理服务器</code> 向 <code>目标服务器</code> 转发请求，并将获得的内容返回给 <code>客户端</code>。</p>
<h3 id="常见场景："><a href="#常见场景：" class="headerlink" title="常见场景："></a>常见场景：</h3><ul>
<li>访问 国外技术 网站</li>
<li>早些年，没有使用 node 时的前后端分离，常用 Tomcat, IIS 作为 Web 服务器，这种方式就是 正向代理。</li>
</ul>
<h3 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a><strong>正向代理的用途</strong></h3><ul>
<li><strong>突破访问限制</strong></li>
</ul>
<p>通过代理服务器，可以突破自身 IP 访问限制，访问国外网站，教育网等。</p>
<ul>
<li><strong>提高访问速度</strong></li>
</ul>
<p>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到<strong>缓冲区</strong>中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p>
<ul>
<li><strong>隐藏客户端真实 IP</strong></li>
</ul>
<p>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p>
<h2 id="2-反向代理（reverse-proxy）"><a href="#2-反向代理（reverse-proxy）" class="headerlink" title="2. 反向代理（reverse proxy）"></a>2. 反向代理（reverse proxy）</h2><p>用 <code>代理服务器</code> 接收 <code>客户端</code> 的连接请求，将请求转发给 <code>目标服务器</code>，然后将 <code>目标服务器</code> 返回的结果，再返回给 <code>客户端</code>。 </p>
<h3 id="常见场景：-1"><a href="#常见场景：-1" class="headerlink" title="常见场景："></a>常见场景：</h3><ul>
<li><p>负载均衡（Nginx）：客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给其中一台服务器来执行，再把执行结果返回给客户端。</p>
</li>
<li><p>前端 Node 服务。</p>
</li>
<li><ul>
<li><strong>为什么 Node.js 要用 反向代理？</strong> （<a target="_blank" rel="noopener" href="https://www.yisu.com/zixun/489265.html%EF%BC%89">https://www.yisu.com/zixun/489265.html）</a></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>Node.js 是高可塑性的。它可以从文件系统架设静态资源服务、对 HTTP 响应执行 gzip 压缩、内建支持  HTTPS，另有很多其它特性。它甚至有能力通过 cluster 模块，运行一个应用的多个实例并分发其自身的请求。然而，基本上让一个反向代理来处理这些操作，而不是靠 Node.js 应用去做。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a><strong>反向代理的用途</strong></h3><ul>
<li><strong>隐藏服务器真实 IP</strong></li>
</ul>
<p>使用反向代理，可以对客户端隐藏服务器的IP地址。</p>
<ul>
<li><strong>负载均衡</strong></li>
</ul>
<p>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p>
<ul>
<li><strong>提高访问速度</strong></li>
</ul>
<p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容<strong>提供缓存服务</strong>，提高访问速度。</p>
<p>即，二房东同样有房屋信息和钥匙。</p>
<ul>
<li><strong>提供安全保障</strong></li>
</ul>
<p>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS&#x2F;DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</p>
<h2 id="3-区别："><a href="#3-区别：" class="headerlink" title="3. 区别："></a>3. 区别：</h2><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p>
<p>1、<strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</p>
<p>2、<strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</p>
<p>3、<strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</p>
<p>4、正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1418457">https://cloud.tencent.com/developer/article/1418457</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-10-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/综合/" title="综合">综合 </a><span class="leancloud_visitors"></span><span>大约1440个字, 4分钟48秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/02-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/">防抖节流</a></h3></div><div class="post-content"><div class="card"><p><h2 id="1-防抖："><a href="#1-防抖：" class="headerlink" title="1. 防抖："></a>1. 防抖：</h2><h3 id="1-1-防抖"><a href="#1-1-防抖" class="headerlink" title="1.1 防抖"></a>1.1 防抖</h3><p>在一定时间n秒内，多次重复触发（重复触发时重新计时），只在最后一次触发后n秒执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args1</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args1)</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul>
<li>键盘输入input框监听，搜索内容时在最后发送一次请求</li>
<li>手机号、邮箱验证输入时</li>
<li>窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<h3 id="1-2-防抖（立即执行）"><a href="#1-2-防抖（立即执行）" class="headerlink" title="1.2 防抖（立即执行）"></a>1.2 防抖（立即执行）</h3><p>在一定时间n秒内，多次重复触发（重复触发时重新计时），只在第一次触发后n秒执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖（立即执行）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce2</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// let flag = false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// if (!flag) &#123;  //直接用timer是否为空判断，更简洁</span></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ul>
<li>表单提交按钮的触发</li>
</ul>
<h2 id="2-节流："><a href="#2-节流：" class="headerlink" title="2. 节流："></a>2. 节流：</h2><p> 在 n  秒内只运行一次，若在 n 秒内重复触发，只有延迟时间到后那一次生效。</p>
<h3 id="2-1-节流（定时器）"><a href="#2-1-节流（定时器）" class="headerlink" title="2.1 节流（定时器）"></a>2.1 节流（定时器）</h3><p>触发 n 秒后，执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流（定时器）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-节流（时间戳）"><a href="#2-2-节流（时间戳）" class="headerlink" title="2.2 节流（时间戳）"></a>2.2 节流（时间戳）</h3><p>停止触发时，若时间间隔不够，则无法执行函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流（时间戳）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (now - last &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            last = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4><ul>
<li>提交等接口，防止重复调用多次</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。</li>
</ul>
<h2 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h2><ul>
<li>防抖是重复触发时，不断清除定时器，重置初始时间，直到n秒内不再触发再执行一次</li>
<li>节流是重复触发时，挂起&#x2F;不调用函数，以此方式阻止重复执行</li>
<li>函数防抖关注一定时间连续触发的事件，只在最后执行一次；而函数节流关注一段时间内只执行一次</li>
</ul>
<h2 id="4-附-完整测试代码"><a href="#4-附-完整测试代码" class="headerlink" title="4. 附 - 完整测试代码"></a>4. 附 - 完整测试代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    防抖：    &lt;input id=&quot;debounce&quot; &gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    防抖（立即执行）：    &lt;input id=&quot;debounce2&quot; &gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    节流（定时器）：    &lt;input id=&quot;throttled&quot; &gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    节流（时间戳）：    &lt;input id=&quot;throttled2&quot; &gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function ajax() &#123;</span><br><span class="line">        let v = arguments[0]</span><br><span class="line">        let label = arguments[1]</span><br><span class="line">        console.log(label + &#x27;：&#x27; + v)</span><br><span class="line">    &#125;</span><br><span class="line">    // 封装节流防抖后的ajax</span><br><span class="line">    function packingAjax(type) &#123;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return debounce(ajax, 1000) // 不可写成 ajax(),会立即执行ajax方法，便会失去延迟效果</span><br><span class="line">                break</span><br><span class="line">            case 1:</span><br><span class="line">                // throttled(ajax(v, txt), 1000)</span><br><span class="line">                return throttled(ajax, 3000)</span><br><span class="line">                break</span><br><span class="line">            case 2:</span><br><span class="line">                return debounce2(ajax, 1000)</span><br><span class="line">                break</span><br><span class="line">            case 3:</span><br><span class="line">                return throttled2(ajax, 3000)</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 防抖</span><br><span class="line">    function debounce(fn, delay) &#123;</span><br><span class="line">        let timer</span><br><span class="line">        return function (...args1) &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            timer = setTimeout(()=&gt;&#123;</span><br><span class="line">                fn.apply(this, args1)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let d = document.getElementById(&#x27;debounce&#x27;)</span><br><span class="line">    let packing = packingAjax(0)</span><br><span class="line">    // 注意！！！</span><br><span class="line">    // 必须放外层，若放在监听中，则每次都会调用 debounce(ajax, 1000) 一次，便每次都要初始化timer，失去回调意义</span><br><span class="line">    d.addEventListener(&quot;keyup&quot;, function (e) &#123;</span><br><span class="line">        packing(e.target.value, &#x27;防抖&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 防抖（立即执行）</span><br><span class="line">    function debounce2(fn, delay) &#123;</span><br><span class="line">        let timer = null</span><br><span class="line">        // let flag = false</span><br><span class="line">        return function (...args) &#123;</span><br><span class="line">            // if (!flag) &#123;  //直接用timer是否为空判断，更简洁</span><br><span class="line">            if (!timer) &#123;</span><br><span class="line">                fn.apply(this, args)</span><br><span class="line">            &#125;</span><br><span class="line">            if (timer) clearTimeout(timer)</span><br><span class="line">            timer = setTimeout(()=&gt;&#123;</span><br><span class="line">                timer = null</span><br><span class="line">            &#125;, delay)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let d2 = document.getElementById(&#x27;debounce2&#x27;)</span><br><span class="line">    let packing2 = packingAjax(2)</span><br><span class="line">    d2.addEventListener(&quot;keyup&quot;, function (e) &#123;</span><br><span class="line">        packing2(e.target.value, &#x27;防抖（立即执行）&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 节流（定时器）</span><br><span class="line">    function throttled(fn, delay) &#123;</span><br><span class="line">        let timer = null</span><br><span class="line">        return function (...args) &#123;</span><br><span class="line">            if (!timer) &#123;</span><br><span class="line">                timer = setTimeout(()=&gt;&#123;</span><br><span class="line">                    fn.apply(this, args)</span><br><span class="line">                    clearTimeout(timer)</span><br><span class="line">                    timer = null</span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let t = document.getElementById(&#x27;throttled&#x27;)</span><br><span class="line">    let packing1 = packingAjax(1)</span><br><span class="line">    t.addEventListener(&quot;keyup&quot;, function (e) &#123;</span><br><span class="line">        packing1(e.target.value, &#x27;节流（定时器）&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 节流（时间戳）</span><br><span class="line">    function throttled2(fn, delay) &#123;</span><br><span class="line">        let last = 0</span><br><span class="line">        return function (...args) &#123;</span><br><span class="line">            let now = new Date()</span><br><span class="line">            if (now - last &gt;= delay) &#123;</span><br><span class="line">                fn.apply(this, args)</span><br><span class="line">                last = now</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let t2 = document.getElementById(&#x27;throttled2&#x27;)</span><br><span class="line">    let packing3 = packingAjax(3)</span><br><span class="line">    t2.addEventListener(&quot;keyup&quot;, function (e) &#123;</span><br><span class="line">        packing3(e.target.value, &#x27;节流（时间戳）&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-09-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><span class="leancloud_visitors"></span><span>大约1065个字, 3分钟33秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/">微任务与宏任务</a></h3></div><div class="post-content"><div class="card"><p><p>JavaScript是一门单线程、异步、非阻塞、解析类型脚本语言。</p>
<p>宏任务有Event Table、Event Queue，微任务有Event Queue</p>
<p>javascript是一门单线程、异步、非阻塞、解析类型脚本语言。</p>
<h2 id="1-进程-amp-线程"><a href="#1-进程-amp-线程" class="headerlink" title="1. 进程 &amp; 线程"></a>1. 进程 &amp; 线程</h2><h3 id="1-1-进程："><a href="#1-1-进程：" class="headerlink" title="1.1 进程："></a>1.1 进程：</h3><ul>
<li>程序运行的实例</li>
<li>同一程序可以产生多个进程</li>
<li>一个进程包含一个或多个线程</li>
</ul>
<h3 id="1-2-线程："><a href="#1-2-线程：" class="headerlink" title="1.2 线程："></a>1.2 线程：</h3><ul>
<li>操作系统能够进行运算调度的最小单位</li>
<li>一次只能执行一个任务</li>
<li>有自己的调用栈、寄存器环境</li>
<li>同一进程的线程共享进程资源</li>
</ul>
<h3 id="1-3-JS单线程："><a href="#1-3-JS单线程：" class="headerlink" title="1.3 JS单线程："></a>1.3 JS单线程：</h3><p>JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为<strong>JS引擎线程</strong></p>
<h3 id="1-4-浏览器渲染是多线程："><a href="#1-4-浏览器渲染是多线程：" class="headerlink" title="1.4 浏览器渲染是多线程："></a>1.4 浏览器渲染是多线程：</h3><p>但浏览器的渲染进程是提供多个线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程（定时器触发线程只是为 setTimeout(…, n) 定时，n秒后，把它对应的回调函数(callback)交给 <strong>任务队列</strong> 维护，JS引擎线程会在适当的时候去任务队列取出任务并执行。）</li>
<li>异步http请求线程</li>
<li>GUI渲染线程</li>
</ul>
<p><img src="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/1650942425429-e24c82db-1b8e-4420-bebe-bb6f759831e7.png" alt="img"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="2-JavaScript的运行机制"><a href="#2-JavaScript的运行机制" class="headerlink" title="2. JavaScript的运行机制"></a><strong>2. JavaScript的运行机制</strong></h2><h3 id="2-1-事件循环-event-loop"><a href="#2-1-事件循环-event-loop" class="headerlink" title="2.1 事件循环**(event loop)**"></a>2.1 事件循环**(<strong><strong>event</strong> <strong>loop</strong></strong>)**</h3><p><strong>事件触发线程</strong> 控制通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制，维护<strong>任务队列。</strong></p>
<p>JS引擎线程遇到异步(DOM事件监听、网络请求、setTimeout计时器等…)，会交给相应的线程单独去维护异步任务，等待某个时机(计时器结束、网络请求成功、用户点击DOM)，然后由 <strong>事件触发线程</strong> 将异步对应的 <strong>回调函数</strong> 加入到消息队列中，消息队列中的回调函数等待被执行。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。</p>
<p>具体来说，异步执行的运行机制如下：</p>
<p>（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<p>（1）所有同步任务都在主线程上执行，形成一个<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/11/stack.html">执行栈</a>（execution context stack）。</p>
<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/1664127178058-15b84125-8ae8-45e5-b457-301e7317549f.png" alt="img"></h3><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="2-2-同步任务-synchronous-与异步任务-asynchronous"><a href="#2-2-同步任务-synchronous-与异步任务-asynchronous" class="headerlink" title="2.2 同步任务**(synchronous)与异步任务(asynchronous)**"></a>2.2 同步任务**(synchronous)<strong>与异步任务</strong>(asynchronous)**</h3><p><img src="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/1664127433261-b2c2fd79-c33f-49cc-96e0-2a20739068bb.png" alt="img"></p>
<p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<p>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<h4 id="异步任务举例："><a href="#异步任务举例：" class="headerlink" title="异步任务举例："></a>异步任务举例：</h4><ul>
<li>网络请求</li>
<li>计时器</li>
<li>DOM事件监听</li>
</ul>
<h2 id="3-微任务与宏任务"><a href="#3-微任务与宏任务" class="headerlink" title="3. 微任务与宏任务"></a>3. 微任务与宏任务</h2><p>任务队列（宏任务）和微任务队列的区别很简单，但却很重要：</p>
<ul>
<li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要<strong>在下一次迭代开始之后才会被执行</strong>.</li>
<li>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</li>
</ul>
<h3 id="微任务（microtask）"><a href="#微任务（microtask）" class="headerlink" title="微任务（microtask）"></a>微任务（microtask）</h3><ul>
<li><code>**Promise.then**</code>、<code>**Promise.catch**</code> 和 <code>**Promise.finally**</code></li>
<li><code>process.nextTick</code> (Node.js 环境)</li>
<li>Object.observe() 异步地监视一个对象的修改（已废弃）</li>
<li>MutationObserver</li>
</ul>
<h3 id="宏任务（macrotask）"><a href="#宏任务（macrotask）" class="headerlink" title="宏任务（macrotask）"></a>宏任务（macrotask）</h3><ul>
<li><code>**script**</code></li>
<li>异步网络请求（XHR）</li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li>文件操作(I&#x2F;O)</li>
<li><code>setImmediate</code>(Node.js 环境 和 IE10 支持) （把一些需要长时间运行的操作放在一个回调函数里）</li>
<li><code>UI rendering</code></li>
</ul>
<h3 id="执行顺序规则："><a href="#执行顺序规则：" class="headerlink" title="执行顺序规则："></a>执行顺序规则：</h3><ul>
<li><strong>new Promise 是同步任务，****new Promise 参数中的代码会立即执行</strong></li>
<li><strong>new Promise.then 是微任务，then 的回调函数分发到微任务队列</strong> <strong>(then</strong>链式写法，即then方法后面再调用另一个then方法，第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数**)**</li>
<li>process.nextTick分发到微任务队列</li>
<li>setTimeout，其回调函数被分发到宏任务Event Queue（执行规则：从上到下排序，先进先执行）中（回调会在微任务执行后再执行）</li>
<li>async函数还是基于Promise的一些封装，<strong>async同new Promise</strong>，是同步任务</li>
<li><strong>await 同Promise.then</strong> 是微任务，多个await时，等执行第一个awiait后，再将其后面的任务执行添加到队列。 <strong>await 后面一般是promise，如果不是直接执行返回。await 后面的函数直接按规则执行，如果是promise 就等执行结果得到后，继续执行下面的，这个过程相当于then。</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 这儿是最先执行的</span></span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<h3 id="完整事件循环过程："><a href="#完整事件循环过程：" class="headerlink" title="完整事件循环过程："></a>完整事件循环<strong>过程：</strong></h3><p><img src="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/1664127165470-bab034d7-83c7-4ca9-94ce-370ffa638565.png" alt="img"></p>
<h2 id="4-如何分析执行顺序"><a href="#4-如何分析执行顺序" class="headerlink" title="4. 如何分析执行顺序"></a>4. 如何分析执行顺序</h2><h3 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h3><p><strong>分析过程：</strong></p>
<ul>
<li><strong>先执行同步任务，遇到宏任务放宏任务队列，遇到微任务放到微任务队列。</strong></li>
<li><strong>主线程执行完一圈后，先执行微任务队列，再执行宏任务。</strong></li>
</ul>
<p>（动态修改两个队列：执行到时，增加微任务和宏任务队列；执行后，删掉队列的值）</p>
<ol>
<li>区分同步任务、微任务、宏任务</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">// 宏任务 A</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 同步任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  <span class="comment">// 宏任务 B</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 同步任务</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="comment">// 微任务 A</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  <span class="comment">// 宏任务 D</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>) <span class="comment">// 若此处没有1000毫秒的延迟，则先执行宏任务D，再执行宏任务E</span></span><br><span class="line">  <span class="title function_">resolve</span>(</span><br><span class="line">    <span class="comment">// 宏任务 E</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span>)</span><br><span class="line">    &#125;))</span><br><span class="line">  <span class="comment">// 微任务 B</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 宏任务 C</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 同步任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="comment">// 同步任务</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="comment">// 微任务 C</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>分别记录宏任务和微任务队列，动态入、出队列</li>
</ol>
<ul>
<li>执行同步任务：</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mac A,  mic D(1000ms delay), mic E,  mic C,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td>mic B,</td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5,</td>
</tr>
</tbody></table>
<ul>
<li>执行微任务B</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mac A,  mic D(1000ms delay), mic E,  mic C,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td></td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6</td>
</tr>
</tbody></table>
<ul>
<li>执行宏任务A</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic D(1000ms delay), mic E,  mic C, mic B,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td>mic A</td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3,</td>
</tr>
</tbody></table>
<ul>
<li>执行微任务A</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic D(1000ms delay), mic E, mic C, mic B,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td></td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3, 4,</td>
</tr>
</tbody></table>
<ul>
<li>执行宏任务E</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic D(1000ms delay),  mic C, mic B,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td></td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3, 4, 12,</td>
</tr>
</tbody></table>
<ul>
<li>执行宏任C</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic D(1000ms delay), mic B,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td>mic C</td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3, 4, 12, 7, 8,</td>
</tr>
</tbody></table>
<ul>
<li>执行微任务C</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic D(1000ms delay), mic B,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td></td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3, 4,12, 7, 8, 9</td>
</tr>
</tbody></table>
<ul>
<li>执行宏任B</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic D(1000ms delay),</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td></td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3, 4,12,7, 8, 9, 10</td>
</tr>
</tbody></table>
<ul>
<li>执行宏任D</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td></td>
</tr>
<tr>
<td>结果：</td>
<td>1, 5, 6, 2, 3, 4,12,7, 8, 9, 10, 11</td>
</tr>
</tbody></table>
<h3 id="题目2："><a href="#题目2：" class="headerlink" title="题目2："></a>题目2：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syn</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyFunction</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 此处要等上一句回调成功后再添加到队列</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// syn  直接执行promise的内容！</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="comment">//    mic 1</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// syn</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// mac 1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// mac 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// syn</span></span><br><span class="line"><span class="title function_">asyFunction</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// mic 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 此处回调，要等asyFunction的都执行后再添加到队列中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/1650875287465-c55a9a4f-dc13-4513-98a4-80724ed51837.png" alt="img"></p>
<h3 id="题目3："><a href="#题目3：" class="headerlink" title="题目3："></a>题目3：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用后 syn</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// async2() 是同步任务 ！！！</span></span><br><span class="line">  <span class="comment">// mic 1；</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="comment">// syn</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>); <span class="comment">// 此句相当于在.then 中的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// mic 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mac 1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// syn</span></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="comment">// syn</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/1650875335099-c4123e74-4156-4c5d-9221-e9f54b86578d.png" alt="img"></p>
<p><strong>分析过程：</strong></p>
<ul>
<li>执行同步任务：（<strong>遇到</strong> <strong>Promise</strong>**.<strong><strong>resolve</strong></strong><em>()*</em>***.**<strong>then 直接执行，虽没有new Promise的同步任务执行，但会将then的微任务挂载到队列中</strong>）</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务：</th>
<th>mic 3, mic 1,</th>
</tr>
</thead>
<tbody><tr>
<td>微任务：</td>
<td>mac 1,</td>
</tr>
<tr>
<td>结果：</td>
<td>1, 2, 6，</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://ruanyifeng.com/blog/2014/10/event-loop.html">http://ruanyifeng.com/blog/2014/10/event-loop.html</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-08-27</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><span class="leancloud_visitors"></span><span>大约2334个字, 7分钟46秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/05-%E9%97%AD%E5%8C%85/">闭包</a></h3></div><div class="post-content"><div class="card"><p><h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h2><p><strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong></p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”<strong>定义在一个函数内部的函数</strong>“。</p>
<p>结构：在函数内部返回一个函数。</p>
<p>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function eg3()&#123;</span><br><span class="line">	var n = 9;</span><br><span class="line">	var f2 = function()&#123;</span><br><span class="line">		alert(n);</span><br><span class="line">	&#125;;</span><br><span class="line">	return f2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eg3()();</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">function eg3()&#123;</span><br><span class="line">	var n = 9;</span><br><span class="line">	var f2 = function()&#123;</span><br><span class="line">		alert(n);</span><br><span class="line">	&#125;;</span><br><span class="line">	return f2();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eg3();</span><br></pre></td></tr></table></figure>

<p><strong>闭包原理：</strong></p>
<p>Javascript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><p><strong>闭包的主要用途：</strong></p>
<ul>
<li>读取函数内部的变量</li>
<li>让这些变量的值始终保持在内存中</li>
</ul>
<h3 id="2-1-使用闭包模拟私有方法及变量（封装）"><a href="#2-1-使用闭包模拟私有方法及变量（封装）" class="headerlink" title="2.1 使用闭包模拟私有方法及变量（封装）"></a>2.1 使用闭包模拟私有方法及变量（封装）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;   </span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;      </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;   </span><br><span class="line">    getName : <span class="keyword">function</span>(<span class="params"></span>)&#123;   </span><br><span class="line">      <span class="keyword">return</span> name;   </span><br><span class="line">    &#125;,   </span><br><span class="line">    setName : <span class="keyword">function</span>(<span class="params">newName</span>)&#123;   </span><br><span class="line">      name = newName;   </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数防抖"><a href="#2-2-函数防抖" class="headerlink" title="2.2 函数防抖"></a>2.2 函数防抖</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-缓存变量-or-方法"><a href="#2-3-缓存变量-or-方法" class="headerlink" title="2.3 缓存变量 or 方法"></a>2.3 缓存变量 or 方法</h3><p>f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。nAdd相当于是一个setter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;    </span><br><span class="line">    var name = &quot;default&quot;;       </span><br><span class="line">       </span><br><span class="line">    return &#123;    </span><br><span class="line">       getName : function()&#123;    </span><br><span class="line">           return name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : function(newName)&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">var john = Person();    </span><br><span class="line">print(john.getName());    </span><br><span class="line">john.setName(&quot;john&quot;);    </span><br><span class="line">print(john.getName());    </span><br><span class="line">     </span><br><span class="line">var jack = Person();    </span><br><span class="line">print(jack.getName());    </span><br><span class="line">jack.setName(&quot;jack&quot;);    </span><br><span class="line">print(jack.getName());</span><br></pre></td></tr></table></figure>

<h3 id="2-4-柯里化函数"><a href="#2-4-柯里化函数" class="headerlink" title="2.4 柯里化函数"></a>2.4 柯里化函数</h3><p>为了提升性能，使用柯里化可以缓存一部分能力。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a map and return a function for checking if a key</span></span><br><span class="line"><span class="comment"> * is in that map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建一个map，返回一个检查key是否在map中的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">makeMap</span> (</span><br><span class="line">  <span class="attr">str</span>: string,</span><br><span class="line">  expectsLowerCase?: boolean</span><br><span class="line">): <span class="function">(<span class="params">key: string</span>) =&gt;</span> <span class="literal">true</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;string&gt; = str.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    map[list[i]] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> expectsLowerCase</span><br><span class="line">    ? <span class="function"><span class="params">val</span> =&gt;</span> map[val.<span class="title function_">toLowerCase</span>()]</span><br><span class="line">    : <span class="function"><span class="params">val</span> =&gt;</span> map[val]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是文本输入类型</span></span><br><span class="line"><span class="keyword">var</span> isTextInputType = <span class="title function_">makeMap</span>(<span class="string">&#x27;text,number,password,search,email,tel,url&#x27;</span>);</span><br><span class="line"><span class="title function_">isTextInputType</span>(typeA)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-高阶函数"><a href="#2-5-高阶函数" class="headerlink" title="2.5 高阶函数"></a>2.5 高阶函数</h3><p>高阶函数，简单的说一般都是一个函数，参数是函数，返回值也是函数。一般都用到了闭包作为公共变量或缓存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a cached version of a pure function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> cached&lt;<span class="attr">F</span>: <span class="title class_">Function</span>&gt; (<span class="attr">fn</span>: F): F &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">function</span> <span class="title function_">cachedFn</span> (<span class="attr">str</span>: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> hit = cache[str]</span><br><span class="line">    <span class="keyword">return</span> hit || (cache[str] = <span class="title function_">fn</span>(str))</span><br><span class="line">  &#125;: any)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 cached 后返回的 idToTemplate 每次执行参数都会被 cached 的参数执行，并且缓存在 hit </span></span><br><span class="line"><span class="keyword">const</span> idToTemplate = <span class="title function_">cached</span>(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="title function_">query</span>(id)</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.<span class="property">innerHTML</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-使用闭包的注意点"><a href="#3-使用闭包的注意点" class="headerlink" title="3. 使用闭包的注意点"></a>3. 使用闭包的注意点</h2><ol>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
<li>避免闭包中存在增长闭包的情况，闭包内缓存的值不断循环增加，导致内存泄露。</li>
</ol>
<p>参考资料：<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-07-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><span class="leancloud_visitors"></span><span>大约983个字, 3分钟16秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/">原型与继承</a></h3></div><div class="post-content"><div class="card"><p><h1 id="1-原型"><a href="#1-原型" class="headerlink" title="1. 原型"></a>1. 原型</h1><ul>
<li><strong>原型 是 函数的</strong> <code>**prototype**</code><strong>属性。</strong></li>
<li>每个函数都有一个特殊属性<code>prototype</code>的对象，即原型对象。此函数的实例，共享函数的属性及方法（即原型模式）。</li>
<li>函数的 原型对象（<code>prototype</code>） 中，有一个内部属性 <code>constructor</code>，这个属性指向该函数。</li>
</ul>
<p><img src="/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/1642082982951-cfb4b90d-56d6-42c9-824b-5efd57b515a3.png" alt="img"></p>
<p>一个名为 Fun 的空函数的 prototype 如下：</p>
<p><img src="/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/1661236866684-f4a45173-10f9-44be-a9e7-5e26dcac2915.png" alt="img"></p>
<h1 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h1><h2 id="2-1-proto"><a href="#2-1-proto" class="headerlink" title="2.1 __proto__"></a>2.1 <code>__proto__</code></h2><ul>
<li>从函数的prototype属性派生的。</li>
<li>同 <code>[[prototype]]</code></li>
<li><code>__proto__</code>相当于一个指针，在对象实例和它的构造器之间建立一个链接，用来指向创建它的构造函数的原型对象的（实例的<code>__proto__</code>指向构造器的 <code>prototype</code>）。</li>
</ul>
<h3 id="2-1-1-实例的-proto"><a href="#2-1-1-实例的-proto" class="headerlink" title="2.1.1 实例的 __proto__"></a>2.1.1 实例的 <code>__proto__</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br></pre></td></tr></table></figure>

<p><img src="/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/1661236711839-5db77a2f-9bc4-4d26-a221-fcbcccc6aa26.png" alt="img"></p>
<ul>
<li><code>**Fun.__proto__**</code> <strong>指向内置匿名函数 anonymous，因为 Fun 是个函数对象，默认由 Function 作为类创建</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例的__proto__指向构造器的 prototype</span></span><br><span class="line">f1.<span class="property">__proto__</span> === <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Fun</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Fun.prototype.__proto__</code> 指向<code>Object.prototype</code>，因为 <code>Fun.prototype</code> 是个对象，默认基于 <code>Object</code>函数作为构造函数创建的，故指向 Object.prototype</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/1661242104488-995b8332-02b8-4d60-9f14-380e0a075dbd.png" alt="img"></p>
<ul>
<li>构造函数是一个函数对象，而函数对象都是 Function 构造产生，所以 构造函数的 <code>__proto__</code>指向 Function 的原型</li>
<li>Object 对象直接继承自 Function 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Fun</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一切对象都是继承自 Object对象，Object 对象直接继承根源对象 <code>null</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/1661242430507-fa52d9d6-de00-4324-bd66-42ec6ab079a6.png" alt="img"></p>
<h3 id="2-1-2-类的-proto"><a href="#2-1-2-类的-proto" class="headerlink" title="2.1.2 类的 __proto__"></a>2.1.2 类的 <code>__proto__</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">__proto__</span> === A <span class="comment">// true</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子类的 <code>__proto__</code>属性，表示构造函数的继承，总是指向父类</li>
<li>子类 prototype 属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的原型</li>
<li>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性</li>
</ul>
<p>( <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/?search=extends&x=0&y=0#docs/class-extends#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C__proto__%E5%B1%9E%E6%80%A7">https://es6.ruanyifeng.com/?search=extends&x=0&y=0#docs/class-extends#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C__proto__%E5%B1%9E%E6%80%A7</a> )</p>
<h2 id="2-2-构造函数、原型、实例的关系"><a href="#2-2-构造函数、原型、实例的关系" class="headerlink" title="2.2 构造函数、原型、实例的关系"></a>2.2 构造函数、原型、实例的关系</h2><ul>
<li>每个构造函数都有一个原型对象（<code>prototype</code>）</li>
<li>原型对象的属性<code>constructor</code>指向构造函数本身</li>
<li>构造函数的实例包含一个指向原型对象的内部指针（<code>__proto__</code>）</li>
</ul>
<h1 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h1><p>js面向过程语言，本身不存在继承。继承（inheritance）是面向对象的一个概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">v1</span> = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">v2</span> = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>&#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getV2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getB&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">v3</span> = <span class="string">&#x27;v333&#x27;</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getV1</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getA&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-原型链"><a href="#3-1-原型链" class="headerlink" title="3.1 原型链"></a>3.1 原型链</h2><p><strong>核心</strong>： </p>
<p>使用原型，让一个引用类型继承另一个引用类型的属性和方法。</p>
<p><strong>将子类原型对象指向父类的实例，子类的实例则可以继承父类的属性（即子类的实例的</strong><code>**__proto__**</code><strong>指向父类）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">aa</span> = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child1</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="title class_">Child1</span>()</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="title class_">Child1</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1) <span class="comment">// Child1 &#123;aa: 11&#125;</span></span><br><span class="line"><span class="comment">// 可继承 父类和原型对象上 的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="title function_">getV1</span>(), a1.<span class="title function_">getV2</span>()) <span class="comment">// getA getB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改普通类型的值，其他子类的实例不会被影响</span></span><br><span class="line">a2.<span class="property">v3</span> = <span class="number">123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="property">v3</span>,a2.<span class="property">v3</span>) <span class="comment">// v333 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型的值时，所有子类实例都会被修改</span></span><br><span class="line">a1.<span class="property">obj</span>.<span class="property">name</span> = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="property">obj</span>,a2.<span class="property">obj</span>) <span class="comment">// &#123;name: &#x27;name&#x27;&#125; &#123;name: &#x27;name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：</li>
</ul>
<ol>
<li>子类可以继承父类普通类型的属性，及定义在原型上的方法。</li>
</ol>
<ul>
<li><strong>缺点</strong>：</li>
</ul>
<ol>
<li>无法实现多继承。（一个实例无法指向两个原型）</li>
<li>所有的属性都是共享的（先在实例找，再在原型对象上找），修改引用类型的值时，所有子类实例都会被修改</li>
<li>无法传递参数。</li>
</ol>
<h2 id="3-2-借用构造函数"><a href="#3-2-借用构造函数" class="headerlink" title="3.2 借用构造函数"></a>3.2 借用构造函数</h2><p><strong>核心</strong>： 在子类的构造函数中，apply() 调用父类构造函数（把父类的函数重新运行一遍）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child2</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="title class_">Child2</span>()</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> <span class="title class_">Child2</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型的值时，子类实例不会相互影响</span></span><br><span class="line">b1.<span class="property">obj</span>.<span class="property">name</span> = <span class="string">&#x27;haha&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="property">obj</span>,b2.<span class="property">obj</span>) <span class="comment">// &#123;name: &#x27;haha&#x27;&#125; &#123;name: &#x27;parent&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能继承 父类原型对象上 的属性和方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="property">v3</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="title function_">getV2</span>(), b1.<span class="title function_">getV1</span>())  <span class="comment">// getB TypeError: b1.getV1 is not a function</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：</li>
</ul>
<ol>
<li>可以多继承，可调用几次 apply</li>
<li>解决内部属性会共享的问题（每创建一个子类的实例，都会把父类再重新运行一遍，因此每个子类的实例指向不同的地址）</li>
<li>可以传参，子类的参数会在父类中运行一遍</li>
</ol>
<ul>
<li><strong>缺点</strong>：</li>
</ul>
<ol>
<li>new 创建的实例只是子类的实例，不是父类的实例，只是相当于把父类拷下来再运行一遍。</li>
<li>只能继承父类构造函数中的属性和方法，不能继承父类原型中的属性和方法；（一般会在构造函数中写一些属性，在原型中写一些方法）</li>
</ol>
<h2 id="3-3-组合继承（伪经典）"><a href="#3-3-组合继承（伪经典）" class="headerlink" title="3.3 组合继承（伪经典）"></a>3.3 组合继承（伪经典）</h2><p><strong>原理</strong>：在借用构造函数方式的基础上，使用原型链实现原型属性和方法的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> <span class="title class_">Child3</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c1.<span class="property">v3</span>, c1.<span class="title function_">getV1</span>()) <span class="comment">// getA v333</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ol>
<li>多继承</li>
<li>可以传参</li>
<li>原型的指向也都是正确的</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>构造函数被运行了两次。</strong> 父类的构造函数被调用两次，第一次在创建子类原型 Child.prototype &#x3D; new Parent() 时，第二次在call&#x2F;apply 时，若父类构造函数大或者耗性能，整体性能会受影响。</li>
<li><strong>构造函数中的属性和方法，同时存在于实例和原型中。</strong> 当用 new Parent() 创建实例时，构造函数的属性或方法在子类实例上有一份，在子类的原型上也会有一份，但由于同名覆盖，不会出错。但属性和实例会实例和实例的原型中个存在一份，占用多余内存。</li>
</ol>
<h2 id="3-4-原型式继承"><a href="#3-4-原型式继承" class="headerlink" title="3.4 原型式继承"></a>3.4 原型式继承</h2><p><strong>原理</strong>： 通过 <code>Object.create()</code> 实现字符字面量对象的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Parent2</span> = &#123;</span><br><span class="line"> <span class="attr">v1</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">v2</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>&#125;,</span><br><span class="line"> <span class="attr">getV2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getB&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent2</span>)</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent2</span>)</span><br><span class="line"></span><br><span class="line">d1.<span class="property">v1</span> = <span class="number">123</span></span><br><span class="line">d1.<span class="property">obj</span>.<span class="property">name</span> = <span class="string">&#x27;hhh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d2.<span class="property">v1</span>, d2.<span class="property">obj</span>.<span class="property">name</span>) <span class="comment">// 1 &#x27;hhh&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原型链继承</strong>，是继承一个构造函数。</li>
<li><strong>原型继承</strong>，是继承一个普通对象。</li>
</ul>
<p><strong>缺点</strong>： Object.create方法是浅拷贝，多个实例的引用类型属性指向相同的内存，会相互影响</p>
<h2 id="3-5-寄生式继承"><a href="#3-5-寄生式继承" class="headerlink" title="3.5 寄生式继承"></a>3.5 寄生式继承</h2><p><strong>原理</strong>： 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再想真得是它做了所有工作一样的返回对象。 （将原型继承封装起来，同时增加属性和方法。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPlus</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent2</span>);</span><br><span class="line">	clone.<span class="property">getOrg</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&#x27;hi plus&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="title function_">createPlus</span>(a);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>： 同原型继承</p>
<h2 id="3-6-寄生组合式继承-完美继承"><a href="#3-6-寄生组合式继承-完美继承" class="headerlink" title="3.6 寄生组合式继承(完美继承)"></a>3.6 寄生组合式继承(完美继承)</h2><p><strong>原理</strong>： 寄生组合式继承，就是借用构造函数来继承属性，通过原型链的混成形式来继承方法。</p>
<p>在组合继承的基础上，将 new Parent() 方式修改为 Object.create()，以解决构造函数执行两遍的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child6</span> () &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span> (parent, child) &#123;</span><br><span class="line">	child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent</span>, <span class="title class_">Child6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Child6</span>()</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> <span class="title class_">Child6</span>()</span><br><span class="line"></span><br><span class="line">f1.<span class="property">v1</span> = <span class="number">123</span></span><br><span class="line">f1.<span class="property">obj</span>.<span class="property">name</span> = <span class="string">&#x27;hhh&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="property">v1</span>, f2.<span class="property">obj</span>.<span class="property">name</span>) <span class="comment">// 1 &#x27;parent&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">getV2</span>(), f1.<span class="title function_">getV1</span>())  <span class="comment">// getB getA</span></span><br></pre></td></tr></table></figure>

<p>ES6 中的 extends 关键字直接实现 JavaScript的寄生组合继承。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-10</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><span class="leancloud_visitors"></span><span>大约1956个字, 6分钟31秒读完</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/page/2/">上一页</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>