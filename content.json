{"pages":[],"posts":[{"title":"微任务与宏任务","text":"JavaScript是一门单线程、异步、非阻塞、解析类型脚本语言。 宏任务有Event Table、Event Queue，微任务有Event Queue javascript是一门单线程、异步、非阻塞、解析类型脚本语言。 1. 进程 &amp; 线程1.1 进程： 程序运行的实例 同一程序可以产生多个进程 一个进程包含一个或多个线程 1.2 线程： 操作系统能够进行运算调度的最小单位 一次只能执行一个任务 有自己的调用栈、寄存器环境 同一进程的线程共享进程资源 1.3 JS单线程：JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为JS引擎线程 1.4 浏览器渲染是多线程：但浏览器的渲染进程是提供多个线程的，如下： JS引擎线程 事件触发线程 定时触发器线程（定时器触发线程只是为 setTimeout(…, n) 定时，n秒后，把它对应的回调函数(callback)交给 任务队列 维护，JS引擎线程会在适当的时候去任务队列取出任务并执行。） 异步http请求线程 GUI渲染线程 2. JavaScript的运行机制2.1 事件循环**(event loop)**事件触发线程 控制通过 事件循环 event loop 的机制，维护任务队列。 JS引擎线程遇到异步(DOM事件监听、网络请求、setTimeout计时器等…)，会交给相应的线程单独去维护异步任务，等待某个时机(计时器结束、网络请求成功、用户点击DOM)，然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。 具体来说，异步执行的运行机制如下： （同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 2.2 同步任务**(synchronous)与异步任务(asynchronous)** 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 异步任务举例： 网络请求 计时器 DOM事件监听 3. 微任务与宏任务任务队列（宏任务）和微任务队列的区别很简单，但却很重要： 当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行. 每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。 微任务（microtask） **Promise.then**、**Promise.catch** 和 **Promise.finally** process.nextTick (Node.js 环境) Object.observe() 异步地监视一个对象的修改（已废弃） MutationObserver 宏任务（macrotask） **script** 异步网络请求（XHR） setTimeout setInterval 文件操作(I/O) setImmediate(Node.js 环境 和 IE10 支持) （把一些需要长时间运行的操作放在一个回调函数里） UI rendering 执行顺序规则： new Promise 是同步任务，****new Promise 参数中的代码会立即执行 new Promise.then 是微任务，then 的回调函数分发到微任务队列 (then链式写法，即then方法后面再调用另一个then方法，第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数**)** process.nextTick分发到微任务队列 setTimeout，其回调函数被分发到宏任务Event Queue（执行规则：从上到下排序，先进先执行）中（回调会在微任务执行后再执行） async函数还是基于Promise的一些封装，async同new Promise，是同步任务 await 同Promise.then 是微任务，多个await时，等执行第一个awiait后，再将其后面的任务执行添加到队列。 await 后面一般是promise，如果不是直接执行返回。await 后面的函数直接按规则执行，如果是promise 就等执行结果得到后，继续执行下面的，这个过程相当于then。 1234567891011setTimeout(()=&gt;{ console.log(4)})new Promise((resolve)=&gt;{ console.log(1) // 这儿是最先执行的 resolve()}).then(()=&gt;{ console.log(3)})console.log(2)// 1, 2, 3, 4 完整事件循环过程： 4. 如何分析执行顺序题目1：分析过程： 先执行同步任务，遇到宏任务放宏任务队列，遇到微任务放到微任务队列。 主线程执行完一圈后，先执行微任务队列，再执行宏任务。 （动态修改两个队列：执行到时，增加微任务和宏任务队列；执行后，删掉队列的值） 区分同步任务、微任务、宏任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 同步任务console.log('1');// 宏任务 AsetTimeout(function() { // 同步任务 console.log('2'); // 宏任务 B setTimeout(function (){ console.log(10) }) // 同步任务 new Promise(function(resolve) { console.log('3'); resolve() // 微任务 A }).then(function(){ console.log('4'); })})// 同步任务new Promise(function(resolve){ console.log('5'); // 宏任务 D setTimeout(function (){ console.log(11) }, 1000) // 若此处没有1000毫秒的延迟，则先执行宏任务D，再执行宏任务E resolve( // 宏任务 E setTimeout(function (){ console.log(12) })) // 微任务 B}).then(function(){ console.log('6');})// 宏任务 CsetTimeout(function(){ // 同步任务 console.log('7'); // 同步任务 new Promise(function(resolve){ console.log('8'); resolve() // 微任务 C }).then(function(){ console.log('9'); })}) 分别记录宏任务和微任务队列，动态入、出队列 执行同步任务： 宏任务： mac A, mic D(1000ms delay), mic E, mic C, 微任务： mic B, 结果： 1, 5, 执行微任务B 宏任务： mac A, mic D(1000ms delay), mic E, mic C, 微任务： 结果： 1, 5, 6 执行宏任务A 宏任务： mic D(1000ms delay), mic E, mic C, mic B, 微任务： mic A 结果： 1, 5, 6, 2, 3, 执行微任务A 宏任务： mic D(1000ms delay), mic E, mic C, mic B, 微任务： 结果： 1, 5, 6, 2, 3, 4, 执行宏任务E 宏任务： mic D(1000ms delay), mic C, mic B, 微任务： 结果： 1, 5, 6, 2, 3, 4, 12, 执行宏任C 宏任务： mic D(1000ms delay), mic B, 微任务： mic C 结果： 1, 5, 6, 2, 3, 4, 12, 7, 8, 执行微任务C 宏任务： mic D(1000ms delay), mic B, 微任务： 结果： 1, 5, 6, 2, 3, 4,12, 7, 8, 9 执行宏任B 宏任务： mic D(1000ms delay), 微任务： 结果： 1, 5, 6, 2, 3, 4,12,7, 8, 9, 10 执行宏任D 宏任务： 微任务： 结果： 1, 5, 6, 2, 3, 4,12,7, 8, 9, 10, 11 题目2：123456789101112131415161718192021222324252627282930313233// synconsole.log(1);async function asyFunction () { console.log(2); await console.log(3); await console.log(4); // 此处要等上一句回调成功后再添加到队列 console.log(5); return 6}// syn 直接执行promise的内容！new Promise((resolve, reject) =&gt; { console.log(10); resolve(); // mic 1}).then(res =&gt; { console.log(11);})// synconsole.log(7);// mac 1setTimeout(() =&gt; { console.log(8)}, 0)// mac 2setTimeout(() =&gt; { console.log(9)}, 1000)// synasyFunction().then(res =&gt; { // mic 3 console.log(res) // 此处回调，要等asyFunction的都执行后再添加到队列中}); 题目3：123456789101112131415161718192021222324252627// 调用后 synasync function async1() { console.log(1); // async2() 是同步任务 ！！！ // mic 1； const result = await async2(); // syn console.log(3); // 此句相当于在.then 中的}async function async2() { console.log(2);}Promise.resolve().then(() =&gt; { // mic 3 console.log(4);});// mac 1setTimeout(() =&gt; { console.log(5);});// synasync1();// synconsole.log(6); 分析过程： 执行同步任务：（遇到 Promise**.resolve()****.**then 直接执行，虽没有new Promise的同步任务执行，但会将then的微任务挂载到队列中） 宏任务： mic 3, mic 1, 微任务： mac 1, 结果： 1, 2, 6， 参考： http://ruanyifeng.com/blog/2014/10/event-loop.html https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth","link":"/01-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"title":"防抖节流","text":"1. 防抖：1.1 防抖在一定时间n秒内，多次重复触发（重复触发时重新计时），只在最后一次触发后n秒执行一次。 12345678910// 防抖function debounce(fn, delay) { let timer return function (...args1) { clearTimeout(timer) timer = setTimeout(()=&gt;{ fn.apply(this, args1) }, delay) }} 应用场景： 键盘输入input框监听，搜索内容时在最后发送一次请求 手机号、邮箱验证输入时 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 1.2 防抖（立即执行）在一定时间n秒内，多次重复触发（重复触发时重新计时），只在第一次触发后n秒执行一次。 123456789101112131415// 防抖（立即执行）function debounce2(fn, delay) { let timer = null // let flag = false return function (...args) { // if (!flag) { //直接用timer是否为空判断，更简洁 if (!timer) { fn.apply(this, args) } if (timer) clearTimeout(timer) timer = setTimeout(()=&gt;{ timer = null }, delay) }} 应用场景： 表单提交按钮的触发 2. 节流： 在 n 秒内只运行一次，若在 n 秒内重复触发，只有延迟时间到后那一次生效。 2.1 节流（定时器）触发 n 秒后，执行。 12345678910111213// 节流（定时器）function throttled(fn, delay) { let timer = null return function (...args) { if (!timer) { timer = setTimeout(()=&gt;{ fn.apply(this, args) clearTimeout(timer) timer = null }, delay) } }} 2.2 节流（时间戳）停止触发时，若时间间隔不够，则无法执行函数。 1234567891011// 节流（时间戳）function throttled2(fn, delay) { let last = 0 return function (...args) { let now = new Date() if (now - last &gt;= delay) { fn.apply(this, args) last = now } }} 应用场景： 提交等接口，防止重复调用多次 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。 3. 区别 防抖是重复触发时，不断清除定时器，重置初始时间，直到n秒内不再触发再执行一次 节流是重复触发时，挂起/不调用函数，以此方式阻止重复执行 函数防抖关注一定时间连续触发的事件，只在最后执行一次；而函数节流关注一段时间内只执行一次 4. 附 - 完整测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 防抖： &lt;input id=&quot;debounce&quot; &gt;&lt;/div&gt;&lt;div&gt; 防抖（立即执行）： &lt;input id=&quot;debounce2&quot; &gt;&lt;/div&gt;&lt;div&gt; 节流（定时器）： &lt;input id=&quot;throttled&quot; &gt;&lt;/div&gt;&lt;div&gt; 节流（时间戳）： &lt;input id=&quot;throttled2&quot; &gt;&lt;/div&gt;&lt;script&gt; function ajax() { let v = arguments[0] let label = arguments[1] console.log(label + '：' + v) } // 封装节流防抖后的ajax function packingAjax(type) { switch (type) { case 0: return debounce(ajax, 1000) // 不可写成 ajax(),会立即执行ajax方法，便会失去延迟效果 break case 1: // throttled(ajax(v, txt), 1000) return throttled(ajax, 3000) break case 2: return debounce2(ajax, 1000) break case 3: return throttled2(ajax, 3000) break } } // 防抖 function debounce(fn, delay) { let timer return function (...args1) { clearTimeout(timer) timer = setTimeout(()=&gt;{ fn.apply(this, args1) }, delay) } } let d = document.getElementById('debounce') let packing = packingAjax(0) // 注意！！！ // 必须放外层，若放在监听中，则每次都会调用 debounce(ajax, 1000) 一次，便每次都要初始化timer，失去回调意义 d.addEventListener(&quot;keyup&quot;, function (e) { packing(e.target.value, '防抖') }) // 防抖（立即执行） function debounce2(fn, delay) { let timer = null // let flag = false return function (...args) { // if (!flag) { //直接用timer是否为空判断，更简洁 if (!timer) { fn.apply(this, args) } if (timer) clearTimeout(timer) timer = setTimeout(()=&gt;{ timer = null }, delay) } } let d2 = document.getElementById('debounce2') let packing2 = packingAjax(2) d2.addEventListener(&quot;keyup&quot;, function (e) { packing2(e.target.value, '防抖（立即执行）') }) // 节流（定时器） function throttled(fn, delay) { let timer = null return function (...args) { if (!timer) { timer = setTimeout(()=&gt;{ fn.apply(this, args) clearTimeout(timer) timer = null }, delay) } } } let t = document.getElementById('throttled') let packing1 = packingAjax(1) t.addEventListener(&quot;keyup&quot;, function (e) { packing1(e.target.value, '节流（定时器）') }) // 节流（时间戳） function throttled2(fn, delay) { let last = 0 return function (...args) { let now = new Date() if (now - last &gt;= delay) { fn.apply(this, args) last = now } } } let t2 = document.getElementById('throttled2') let packing3 = packingAjax(3) t2.addEventListener(&quot;keyup&quot;, function (e) { packing3(e.target.value, '节流（时间戳）') })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/02-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"},{"title":"内存","text":"1. 内存模型内存空间分为 **栈(stack)、堆(heap)、池(一般也会归类为栈中)**。 其中栈存放变量，堆存放复杂对象，池存放常量。 1.1 栈内存栈是一种特殊的列表。 存取：先进后出 存储基本数据类型： String、Number、boolean、null、undefined、Symbol 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。 1.2 堆内存堆是一种经过排序的树形数据结构，每个结点都有一个值。 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。 由于堆的这个特性，常用来实现优先队列。 存取：随意 存储引用数据类型：Object、Array、Function等 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得值。 1234var a = 123; // 变量 a 存在栈中// 变量 b 存在栈中，b的值是{age: 18}的引用地址；{age: 18}作为对象存在堆内存var b = { age: 18 }; 1.2.1 为什么可以改变 const 的值？ES6语法中的 const 声明一个只读的常量。一旦声明，常量的值就不能改变。但是下面的代码可以改变 const 的值，这是为什么？ 1234const foo = {};foo.prop = 123;foo.prop // 123; // 可以修改const，不报错foo = {}; // TypeError: &quot;foo&quot; is read-only 因为const foo存的{}的地址，当foo直接改变地址时，就违反了改变的原则；而当{}中增加属性值时，foo的引用地址没改变，所以可以修改。 1.3 简单类型和复杂类型的区别 声明变量时不同的内存地址分配： 简单类型的值存放在栈中，在栈中存放的是对应的值 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址 不同的类型数据导致赋值变量时的不同： 简单类型赋值，是生成相同的值，两个对象对应不同的地址 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象 2. 内存的生命周期： 分配需要的内存 JavaScript 在定义变量或者创建一个变量的时候，就完成了内存分配。 使用分配到的内存（读、写操作） 不需要时将其释放、归还 “垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。 3. 垃圾回收机制（GC）Java garbage collection (GC) 3.1 JavaScript 的自动垃圾收集机制就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此 a = null 其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 3.1.1 如何判断一个变量已经死了？一个对象在已经没有引用时。 全局变量：会到程序执行完毕，才会被回收； 局部变量：函数执行结束后，如果有外部引用，则不能被回收；没有便可以被回收； 1234567var a= {a: 123} // {a: 123} 有a引用function b(){ var b1 = 1; var c ={a:1} return b1;}var a = b();//如果return b1,则b1会被回收；如果return c，c不会被回收； 3.1.2 到底什么时候回收？JavaScript 是自动回收机制，以下是可能会触发的情况： 执行完一次主线程（或宏任务、微任务），就会回收一次 当内存不够时，一次执行中可能也会触发回收 3.2 引用计数算法 引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。 123456789101112// 创建一个对象person，有两个指向属性age和name的引用var person = { age: 12, name: 'aaaa'};person.name = null; // 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null; //原person对象已经没有引用，很快会被回收 限制：循环引用会导致内存泄露循环引用：两个对象相互引用，尽管它们不再使用，也不会进行回收，导致内存泄露。 该算法有个限制：无法处理循环引用的事例。在下面的例子1中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 案例1： 12345678910function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return &quot;azerty&quot;;}f(); 案例2： 如：创建一个DOM元素并绑定一个点击事件，变量div有事件处理函数的引用，同时事件处理函数也有div的引用。 123456var div;window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);}; 在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。 3.3 标记清除算法从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。 这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。 简单说，将那些无法由根部触触发到的对象标记为不再使用，稍后进行回收。 此算法避免内存泄露的方法： 明确切断需要回收的对象与根部的联系 限制：那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。 3.4 V8引擎3.4.1 堆内存大小在V8引擎的堆内存的大小上限在64位系统中为 1464MB，在32位系统中则为 732MB（在node 环境有 C++ 加持下，会略扩容） 3.4.2 堆内存对象的分代管理V8引擎对堆内存中的 JavaScript 对象进行分代管理。 “垃圾变量”：不再使用的变量或没有被引用的对象。 3.4.2.1 新生代：短时间存活的新变量会存在新生代中，新生代的内存量极小。在 64位系统下，约32M。 新生代的回收算法: 新生代空间一分为二，分为 from: 16M、to: 16M(一直空的) 区。 核心：复制 - 清空 过程： 删掉垃圾变量，把from存活的变量复制到to，把from清空，再把to和from的名字对调。 优势： 这样可以提升回收速度，时间复杂度低，牺牲空间换时间。不用像老生代那样整理磁盘。 3.4.2.2 老生代：生存时间比较长的变量，会转存到老生代，老生代占据了几乎所有内存。在 64位系统下，约1.4G。 老生代回收算法： 标记垃圾变量 清除垃圾变量 整理磁盘（）– 为什么要整理磁盘？ 如果清除的垃圾变量是多个不连续的变量，虽然空间够，但如果要存一个数组，而数组存储，必须是在连续的内存空间，多个不连续的空白空间不能存储数组。 如何整理磁盘？ 把空出来的内存位置移动合并，留最后整个统一的空白块 3.4.2.3 新生代什么时候转换到老生代？ 新生代发现本次复制（from-&gt; to复制）后，会占用超过25%的to空间 这个对象已经在新生代经历过一次回收 就会将新生代变量放到老生代。 3.4.3 为什么 JavaScript 要限制内存，设置 1.4G？ JavaScript 是脚本语言，而脚本语言的特性是一次执行的，没必要弄太大； 而Java 这类是后端语言，是作为服务的，会一直开着运行，也就会不断增加内存。 核心原因：垃圾回收是阻塞式的（阻塞式是如果要进行垃圾回收，会中断代码执行，而 JavaScript 是单线程的） 而进行一次 1.4G 的垃圾回收，大约需要1s。 如果垃圾太大，垃圾回收耗时久，用户直观看页面感知非常明显；但后端如果中断1s相对影响不大。 4. 检测内存4.1 浏览器端1window.performance.memory 在 DevTools 中，使用 Memory 工具。 Shallow Size：对象本身占用内存的大小，不包含其引用的对象。 常规对象（非数组）的 Shallow size 由其成员变量的数量和类型决定。 数组的shallow size由数组元素的类型及数组长度决定 Retained Size：对象的Retained Size = 对象本身的Shallow Size + 对象能直接或间接访问到的对象的Shallow Size Heap Size:堆的大小，当资源增加，当前堆的空间不够时，系统会增加堆的大小，若超过上限（如64M，阈值视平台而定）则会被杀掉 。 Allocated:堆中已分配的大小，即 App 应用实际占用的内存大小，资源回收后，此项数据会变小。 4.2 Node 端12// 已使用的内存process.memoryUsage() Node端可以手动触发垃圾回收：global.gc （因为其源码是C++） Node端可以设置内存： Node 新版是可以自动扩，如下将内存设置到最大： 12345// 执行 test.js 文件，设置最大的老生代空间为1700Mnode --max-old-space-size=1700 test.js // 单位是MB// 执行 test.js 文件，设置最大的新生代空间为1024Mnode --max_semi_space_size=1024 test.js // 单位是KB 5. 优化内存 少定义全局变量； 如果一定要定义全局变量，可以用完后，手动释放掉，如 a=undefined;a=null; (原理：将引用类型赋值为基本类型，去引用)； 注意增长闭包情况； 5.1 增长闭包：普通闭包，对象数据量不大，对整个项目一般影响不大，但需注意增长闭包。 如下例子，是会无限增长的闭包： 12345678(funciotn(){ var arr = [] return (item)=&gt;{ if(arr.length&gt;0){ //可通过限制条数，规避对内存的影响 arr.push(item) } }}){} 6. WeakMapES6 推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。 123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 参考： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management https://juejin.cn/post/6844903615300108302 https://www.imooc.com/article/13489 http://www.ruanyifeng.com/blog/2017/04/memory-leak.html","link":"/03-%E5%86%85%E5%AD%98/"},{"title":"源码学习入口","text":"1. 入口文件package.json 根据运行命令，去找 dev 后配置，即找 scripts/config.js 文件的 web-full-dev 12345{ &quot;scripts&quot;: { &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;, }} 2. scripts/config.js 初始化配置 config，引入 entry-runtime-with-compiler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// scripts\\config.js...const aliases = require('./alias') // 看 ./alias 文件const resolve = p =&gt; { const base = p.split('/')[0] if (aliases[base]) { return path.resolve(aliases[base], p.slice(base.length + 1)) } else { return path.resolve(__dirname, '../', p) }}// 配置定义const builds = { ... // Runtime+compiler development build (Browser) 'web-full-dev': { entry: resolve('web/entry-runtime-with-compiler.js'), // 看 reslove ，由此找到对应文件真实路径 dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: { he: './entity-decoder' }, banner }, ...}/** * 根据不同的环境，初始化参数 input, plugins, output, __VERSION__ 等 * @param {*} name 环境名 * @returns */function genConfig (name) { const opts = builds[name] // 找 builds 中 name 配置 const config = { input: opts.entry, external: opts.external, plugins: [], output: {} ... } ... return config}// 初始执行入口，找 TARGET 对应配置if (process.env.TARGET) { module.exports = genConfig(process.env.TARGET) // 看 genConfig} else { exports.getBuild = genConfig exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)} **process****.****env****.****TARGET**:这个 process 是nodejs 的 变量， 在 \\node_modules@types\\node\\globals.d.ts 中： declare var process: NodeJS.Process; aliases：根据上面的找./alias 文件，即：scripts/alias.js，由此找到 web/ 对应的文件全路径。 123456789101112// ...module.exports = { vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), sfc: resolve('src/sfc')} 由此找到 entry: resolve('web/entry-runtime-with-compiler.js'), 拼接后的入口文件路径： 1src/platforms/web/entry-runtime-with-compiler.js 3. platforms/web/entry-runtime-with-compiler.js 导入 ./runtime/index，见 4.1； 扩展 Vue.prototype.$mount 方法； 导入 ./compiler/index 的 compileToFunctions 方法，挂载到 Vue.compile，见 4.2； 123456789101112131415161718192021...// 引入 /runtime/index 文件, 初始化 vueimport Vue from './runtime/index'...// 引入 /compiler/index 文件，初始化 compile 编译方法import { compileToFunctions } from './compiler/index'...// 扩展 $mount 挂载方法const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { ... return mount.call(this, el, hydrating)}...// 定义 compile 方法Vue.compile = compileToFunctionsexport default Vue 4.1 platforms/web/runtime/index.js 导入 core/index ，vue 核心代码 定义 $mount 挂载方法 123456789101112131415// 初始化 vue 核心代码import Vue from 'core/index'...// 定义 $mount 挂载方法Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { // 初始化挂载组件 el = el &amp;&amp; inBrowser ? query(el) : undefined ... return mountComponent(this, el, hydrating)}...export default Vue 4.1.2 core/index.js 导入 core/instance/index.js 初始化 全局 API 方法，initGlobalAPI(Vue) 12345678// 初始化 vue 实例import Vue from './instance/index'import { initGlobalAPI } from './global-api/index'...// 初始化 Vue 全局 APIinitGlobalAPI(Vue)...export default Vue 4.1.2.1 ./instance/index 详见：02- ‘src/core/instance/index.js’ 4.1.2.2 initGlobalAPI(Vue) 详见：03 - core/global-api/index.js 4.2 platforms/web/compile/index.js 通过 createCompiler(baseOptions) 初始化 compile， compileToFunctions 方法 123456import { baseOptions } from './options'import { createCompiler } from 'compiler/index'const { compile, compileToFunctions } = createCompiler(baseOptions)export { compile, compileToFunctions } 附： 调试方法（基于 v2.6.14） npm install 找到 examples 文件夹，打开任意一个，如 markdowm/index.html，将引入的文件的vue文件由min修改为 直接浏览器打开 index.html 文件即可调试，如 file:///E:/workSpaces/vue-2.6.14/examples/markdown/index.html","link":"/101-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%85%A5%E5%8F%A3/"},{"title":"initProxy","text":"【前情回顾】 123456789101112// src\\core\\instance\\init.jsVue.prototype._init = function (options?: Object) { ... if (process.env.NODE_ENV !== 'production') { // 开发环境时，调用initProxy方法 // 如果不是开发环境，则vue实例的_renderProxy属性指向vue实例本身。 initProxy(vm) } else { vm._renderProxy = vm } ...} 1. initProxy 最核心的代码就是 vm._renderProxy = new Proxy(vm, handlers)，通过 Proxy 进行 handlers 拦截检测处理 ，将结果赋值给 vm._renderProxy。 其中，handlers 中主要检测 vm 的属性拦截校验。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364...let initProxyif (process.env.NODE_ENV !== 'production') { // 根据 makeMap 的实现，将这个字符串转换为类似对象 {Infinity: true, undefined: true, ...} const allowedGlobals = makeMap( 'Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify ) // 属性或方法未定义，报警告 const warnNonPresent = (target, key) =&gt; { warn( `Property or method &quot;${key}&quot; is not defined on the instance but ` + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target ) } // 属性 key 以 $ 或者 _ 开头，报警告（避免与内置属性方法冲突） const warnReservedPrefix = (target, key) =&gt; { warn( `Property &quot;${key}&quot; must be accessed with &quot;$data.${key}&quot; because ` + 'properties starting with &quot;$&quot; or &quot;_&quot; are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target ) } /* // 检测是不是支持原生方法 export function isNative (Ctor: any): boolean { return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString()) } */ // 判断是否支持 Proxy const hasProxy = typeof Proxy !== 'undefined' &amp;&amp; isNative(Proxy) ... const hasHandler = {...} const getHandler = {...} initProxy = function initProxy (vm) { // 判断当前环境是否支持 Proxy，支持就用 Proxy 代理后赋值 vm._renderProxy if (hasProxy) { // determine which proxy handler to use const options = vm.$options const handlers = options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler vm._renderProxy = new Proxy(vm, handlers) } else { vm._renderProxy = vm } } }}export { initProxy } 调试时，只看到调 hasHandler，不知什么时候调 getHandler，查资料如下： handers函数会根据 options.render._withStripped的不同执行不同的代理函数，当使用类似webpack这样的打包工具时，通常会使用vue-loader插件进行模板的编译，这个时候options.render是存在的，并且_withStripped的属性也会设置为true，所以此时代理的选项是hasHandler,在其他场景下，代理的选项是getHandler。getHandler,hasHandler的逻辑相似 关于 _renderProxy 源码中vm._renderProxy的使用出现在Vue实例的_render方法中，Vue.prototype._render是将渲染函数转换成Virtual DOM的方法，这部分是关于实例的挂载和模板引擎的解析，笔者并不会在这一章节中深入分析，我们只需要先有一个认知，Vue内部在js和真实DOM节点中设立了一个中间层，这个中间层就是Virtual DOM，遵循js -&gt; virtual -&gt; 真实dom的转换过程,而Vue.prototype._render是前半段的转换，当我们调用render函数时，代理的vm._renderProxy对象便会访问到。 1.1 hasHandler123456789101112131415161718const hasHandler = { // target 是目标代理的对象； key 是需要检查是否存在的属性 // 此方法拦截检测模板中的属性，检测是否合法 has (target, key) { console.log('key', key) // 辅助理解，打印 key // 此处的target就是 Vue 实例 // key 是否在 target 中的标记 const has = key in target // (key 在上文全局 Globals 字符串中 || key 以`_`开头且 key 不属于 target 的 $data 的属性) 则为 true const isAllowed = allowedGlobals(key) || (typeof key === 'string' &amp;&amp; key.charAt(0) === '_' &amp;&amp; !(key in target.$data)) if (!has &amp;&amp; !isAllowed) { if (key in target.$data) warnReservedPrefix(target, key) else warnNonPresent(target, key) } return has || !isAllowed }} 此方法是为了拦截模板中的属性进行校验， eg: 如下这段示例代码，打印出 hasHandler 中 的 has 的 key 值： 1234567891011121314151617181920212223&lt;div id=&quot;editor&quot;&gt; &lt;textarea :value=&quot;input + new Date()&quot; @input=&quot;update&quot;&gt;&lt;/textarea&gt; &lt;div v-html=&quot;compiledMarkdown&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#editor', data: { input: '# hello' }, computed: { compiledMarkdown: function () { return marked(this.input, { sanitize: true }) } }, methods: { update: _.debounce(function (e) { this.input = e.target.value }, 300) } })&lt;/script&gt; 原示例中 &lt;textarea :value=&quot;input&quot; 没有 new Date()，则打印的 key 值也没有 Date。 这个理解辅助理解 allowedGlobals(key)的意义，说明如果模板中使用原生一些对象，是不会被拦截的。 【辅助】makeMap12345678910111213141516171819202122232425// src\\shared\\util.js/** * Make a map and return a function for checking if a key * is in that map. * 调用eg：makeMap('a','b','c')('a') // 返回true * 1.第一组参数 (str,expectsLowerCase) ，将字符串格式化为对象 * &quot;a,b,c&quot; ==&gt; {a: true, b: true, c: true} * 2. 第二组参数 return 的 val，校验val是否存在str中，若存在返回 true，不存在返回undefined */export function makeMap ( str: string, expectsLowerCase?: boolean): (key: string) =&gt; true | void { const map = Object.create(null) // 将类似格式的字符串 &quot;a,b,c&quot; 拆成数组 [a,b,c] const list: Array&lt;string&gt; = str.split(',') for (let i = 0; i &lt; list.length; i++) { // 将类似格式的数组[a,b,c] 转换为 {a: true, b: true, c: true} map[list[i]] = true } // 统一大小写处理，返回 val 是否在 map 中，存在返回 true，不存在返回undefined return expectsLowerCase ? val =&gt; map[val.toLowerCase()] : val =&gt; map[val]} 2. Proxy 对象2.1 概念Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 1234// target: 所要拦截的目标对象// handler: 处理器对象，用于设置拦截行为new Proxy(target, handler) 2.2 术语 target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler 处理器对象（包含trap） traps 捕捉器， 提供属性访问的方法 2.3 拦截器 handler下面是 Proxy 支持的拦截操作一览，一共 13 种。 **get(target, propKey, receiver)**：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 **has(target, propKey)**：拦截propKey in proxy的操作，返回一个布尔值。 **deleteProperty(target, propKey)**：拦截delete proxy[propKey]的操作，返回一个布尔值。 **ownKeys(target)**：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 **getOwnPropertyDescriptor(target, propKey)**：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 **defineProperty(target, propKey, propDesc)**：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 **preventExtensions(target)**：拦截Object.preventExtensions(proxy)，返回一个布尔值。 **getPrototypeOf(target)**：拦截Object.getPrototypeOf(proxy)，返回一个对象。 **isExtensible(target)**：拦截Object.isExtensible(proxy)，返回一个布尔值。 **setPrototypeOf(target, proto)**：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 参考： https://cloud.tencent.com/developer/article/1821611 https://juejin.cn/post/6844903812285595662 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy https://es6.ruanyifeng.com/#docs/proxy","link":"/104-initProxy/"},{"title":"nextTick","text":"1. nextTick 与 $nextTick全局 API Vue.nextTick()[Vue.nextTick( callback, context] )在下次 DOM 更新循环结束之后执行延迟回调。 在修改数据之后立即使用这个方法，获取更新后的 DOM。 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。 123456789101112// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () { // DOM 更新了})// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () { // DOM 更新了 }) 实例方法/实例生命周期 vm.$nextTick()[vm.$nextTick( callback] )将回调延迟到下次 DOM 更新循环之后执行。 在修改数据之后立即使用它，然后等待 DOM 更新。 它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 12345678910111213141516new Vue({ // ... methods: { // ... example: function () { // 修改数据 this.message = 'changed' // DOM 还没有更新 this.$nextTick(function () { // DOM 现在更新了 // `this` 绑定到当前实例 this.doSomethingElse() }) } }}) 2. 源码分析2.1 初始化都是调用的 src/core/util/next-tick.js 的 nextTick 方法 12345678910111213import { nextTick } from '../util/index'// src/core/global-api/index.jsexport function initGlobalAPI (Vue: GlobalAPI) { Vue.nextTick = nextTick}// src/core/instance/render.jsexport function renderMixin (Vue: Class&lt;Component&gt;) { Vue.prototype.$nextTick = function (fn: Function) { return nextTick(fn, this) }} 2.2 调用12345// src/core/observer/scheduler.jsexport function queueWatcher (watcher: Watcher) { nextTick(flushSchedulerQueue)} 2.3 nextTick() 将 回调函数 存到 callbacks 队列 如果有正在执行的，就等待上一个执行结束后，下一次更新执行 事件循环通过微任务或宏任务，再依次执行 callbacks 中的回调函数 123456789101112131415161718192021222324252627282930313233343536// src/core/util/next-tick.js// 全局唯一，异步操作队列const callbacks = []// 标识同一个时间只能执行一次let pending = falseexport function nextTick (cb?: Function, ctx?: Object) { let _resolve // 将入参的 回调函数cb 存到 callbacks队列中 callbacks.push(() =&gt; { if (cb) { try { // 保留 cb 的 this 仍是 ctx cb.call(ctx) } catch (e) { handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) // 若没有正在执行的任务 if (!pending) { pending = true // 将待执行操作加到微/宏任务队列（各个系统方式不同 ，简单理解为 setTimeout（利用 Event Loop）） timerFunc() } // $flow-disable-line // 如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise(resolve =&gt; { _resolve = resolve }) }} 2.4 timerFunc挂起任务的方法，将待执行操作加到微/宏任务队列（微任务优先于宏任务） 优先级为： Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout 12345678910111213141516171819202122232425262728293031323334353637// src/core/util/next-tick.js// 挂起方法，将待执行操作加到微/宏任务队列（各个系统方式不同 ，使用不同的方式）// 优先级为： Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeoutexport let isUsingMicroTask = falselet timerFuncif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) { // 支持 Promise 的，使用 Promise 方式挂起，回调函数放在 then() 中 -- 微任务 const p = Promise.resolve() timerFunc = () =&gt; { p.then(flushCallbacks) if (isIOS) setTimeout(noop) } isUsingMicroTask = true} else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]')) { // 不支持 Promise ,但非IE 且支持 MutationObserver 的，使用 MutationObserver -- 微任务 ... isUsingMicroTask = true} else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) { // 不支持 Promise 和 MutationObserver ， // 但支持 setImmediate，用 setImmediate 挂起 -- 宏任务 timerFunc = () =&gt; { setImmediate(flushCallbacks) }} else { // 以上都不支持的，使用 setTimeout 挂起 -- 宏任务 // Fallback to setTimeout. timerFunc = () =&gt; { setTimeout(flushCallbacks, 0) }} 2.5 flushCallbacks() 执行回调函数，将标志位置为 false 遍历 callbacks 回调队列，挨个执行 1234567891011121314// src/core/util/next-tick.js/** * 遍历 callbacks 队列中的回调函数，挨个执行 */function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { // 挨个执行 copies[i]() }}","link":"/107-nextTick/"},{"title":"hexo搭建","text":"1. 创建 hexo 项目1.1 安装 Hexohttps://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo 12# 安装 hexo 手脚架$ npm install -g hexo-cli 1.2 建站（创建 hexo 项目）123456# 创建项目 &lt;folder&gt;$ hexo init &lt;folder&gt; # 安装项目依赖 $ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678. ├── _config.yml // hexo 项目主要的配置文件 ├── package.json ├── scaffolds // 存放新建blog的模板 ├── source // blog 文件源 | ├── _drafts | └── _posts // 最常用穿件的blog存放位置 └── themes // blog 主题包 1.3 预览网站1hexo server 目录(默认文件结构) 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹，source_dir 下的子目录 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。 1.4 主题修改在 https://hexo.io/themes/ 可以寻找喜欢的主题进行安装。 如：安装 anatole 主题： 1git clone https://gitee.com/Lhcfl/hexo-theme-anatolo.git themes/Anatolo 安装依赖 12npm install hexo-renderer-pug --savenpm install hexo-renderer-stylus --save 安装成功后（在 theme 文件夹下新增一个皮肤包），修改 _config.yml 的配置 ： 2. 创建文章2.1 创建文章默认创建 post 类型 .md文章（文件名默认为.md，文件名无需加 后缀） 1234$ hexo new [layout] &lt;title&gt;# 简便创建，默认layout 为 post$ hexo new &lt;title&gt; 2.2 创建有图片等资源的文件2.2.1 修改 post_asset_folder修改 _config.yml 中 post_asset_folder配置为 true，然后正常创建文章，便会在A.md文章同层多一个A同名文件夹。 图片路径就直接写即可，相当于 图片和文章在同一层级。 1post_asset_folder: true 2.2.2 安装插件 hexo-renderer-marked用于 Markdown 解析和渲染的插件 1npm install hexo-renderer-marked 修改 _config.yml 配置： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 2.3 创建按照年份分类的文章 （此方式暂不可行，会导致图片无法显示）有解决方案的欢迎指点~如果直接创建文章，则默认在 source/_post 文件夹下排排放，修改如下配置后，则可以按创建年份将文章分类到不同文件夹下。 修改 _config.yml ： 12345# 保持不变permalink: :year/:month/:day/:title/# 修改 new_post_namenew_post_name: :year/:title.md 2.4 首页显示部分文章在需要显示后加此句，截断首页显示： 1&lt;!--more--&gt; 3. Github Action 部署项目3.1 github 新建仓库 在github 上新建仓库，仓库名为 {userName}.github.io， userName就是github的用户名 创建成功后，复制仓库http的地址 3.2 部署 安装部署插件 12// 安装部署插件npm install hexo-deployer-git --save 修改 _config.yml 配置 1234deploy: type: git repo: https://github.com/SummerOrange/SummerOrange.github.io branch: master 部署命令 1234$ hexo deploy# 简写$ hexo d 部署完成后，使用仓库名https://summerorange.github.io/即可访问blog。 3.3 如果部署后未修改，可以在github的Actions中查看自动build , run 的情况。 3.4 部署报错若 hexo d后报类似错： 12345678910fatal: unable to access 'https://.../': Encountered end of fileFATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/.../lib/spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }}... 解决方案： 1234567## 在项目的根目录下操作如下：rm -rf .deploy_git/git config --global core.autocrlf falsehexo clean &amp;&amp; hexo g &amp;&amp; hexo d 4. 导入有图片的.md已有 blog 小技巧借助 Typora如果已经在在线笔记类似工具中存有.md文章，如果有图片，一个个下载图改路径，是个苦力活。 可以借助 Typora，先在“偏好设置”中配置，图像 - 对网络位置的图片应用上述规则，配置如下： 配置好后，通过hexo新建好空文档，在 Typora 中将文章直接ctrl + v ，然后将根目录下的图片资源移动到文章对应的文件夹下。 PS：因为hexo中，md 中写的图片路径直接就是图片名称，所以此处配置，不能写./${filename}","link":"/301-hexo%E6%90%AD%E5%BB%BA/"},{"title":"正向代理与反向代理","text":"正向代理 反向代理 代理目标 “代理服务器”代理了”客户端”，去和”目标服务器”进行交互 “代理服务器”代理了”目标服务器”，去和”客户端”进行交互 访问目标服务器时 目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理 客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理 代理服务器 帮助 客户端 请求页面并缓存，再返回给 客户端 代理服务器 将 目标服务器 请求结果缓存到本地，再返回给 客户端 客户端 使用 代理服务器的 IP 和端口去浏览器访问 服务端 使用 代理服务器的 IP 和端口给 客户端 使用 正向代理 （forward proxy）为了从 目标服务器 获取内容，客户端 向 代理服务器 发送一个请求并指定目标，然后 代理服务器 向 目标服务器 转发请求，并将获得的内容返回给 客户端。 常见场景： 访问 国外技术 网站 早些年，没有使用 node 时的前后端分离，常用 Tomcat, IIS 作为 Web 服务器，这种方式就是 正向代理。 正向代理的用途 突破访问限制 通过代理服务器，可以突破自身 IP 访问限制，访问国外网站，教育网等。 提高访问速度 通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。 隐藏客户端真实 IP 上网者也可以通过这种方法隐藏自己的IP，免受攻击。 2. 反向代理（reverse proxy）用 代理服务器 接收 客户端 的连接请求，将请求转发给 目标服务器，然后将 目标服务器 返回的结果，再返回给 客户端。 常见场景： 负载均衡（Nginx）：客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给其中一台服务器来执行，再把执行结果返回给客户端。 前端 Node 服务。 为什么 Node.js 要用 反向代理？ （https://www.yisu.com/zixun/489265.html） Node.js 是高可塑性的。它可以从文件系统架设静态资源服务、对 HTTP 响应执行 gzip 压缩、内建支持 HTTPS，另有很多其它特性。它甚至有能力通过 cluster 模块，运行一个应用的多个实例并分发其自身的请求。然而，基本上让一个反向代理来处理这些操作，而不是靠 Node.js 应用去做。 反向代理的用途 隐藏服务器真实 IP 使用反向代理，可以对客户端隐藏服务器的IP地址。 负载均衡 反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。 提高访问速度 反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。 即，二房东同样有房屋信息和钥匙。 提供安全保障 反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。 3. 区别：虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。 1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。 2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。 3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。 4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。 参考： https://cloud.tencent.com/developer/article/1418457","link":"/302-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"title":"Promise","text":"1. Promise 对象ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise 构造函数接受 一个函数 作为参数。 该函数的两个参数分别是resolve和reject，它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 123456789const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }}); 1.1 Promise 对象实例结构1var promise = new Promise(()=&gt;{}) Promise 的内部属性有 PromiseState``PromiseResult 实例 promise 的 __proto__指向 Promise 的原型对象， 1Promise.prototype == promise.__proto__` 为 `true Promise 原型方法有： then、catch、finally Promise 构造函数方法有：all、allSettled、any、race、resolve、reject。 1.2 状态 Promise对象代表一个异步操作，有三种状态： pending（进行中） fulfilled（已成功） rejected（已失败） 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。改变的情况只有： 从pending变为fulfilled 从pending变为rejected 1234567891011var promise = new Promise(()=&gt;{})var promise2 = new Promise(function(resolve, reject) { console.log('promise2'); resolve('success');});var promise3 = new Promise(function(resolve, reject) { console.log('Promise3'); reject('err');}); 1.3 特点 Promise 是微任务。 Promise 新建后就会立即执行。 调用resolve或reject并不会终结 Promise 的参数函数的执行，即 resolve(‘success’) 后的语句仍执行；但return **resolve**('success') 加上 return 语句后，后面的语句就不执行了。 没有 resolve 或 reject ，promise.then 并不会执行。 console.**log**('1', new Promise(...)); 先执行 new Promise 构造函数的代码，再执行 console.log。 缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 1.4 Promise 嵌套1234567891011121314const p1 = new Promise(function (resolve, reject) { console.log('p1', p1) setTimeout(() =&gt; reject(new Error('fail')), 3000)});const p2 = new Promise(function (resolve, reject) { console.log('p2 a') setTimeout(() =&gt; resolve(p1), 1000) console.log('p2 b', p2)})p2 .then(result =&gt; console.log(result, 'p2', p2, 'p1', p1)) .catch(error =&gt; console.log(error, 'p2', p2, 'p1', p1)) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 2. 原型方法2.1 Promise.prototype.then(onFulfilled[, onRejected])onFulfilled : resolved状态的回调函数 onRejected ：rejected状态的回调函数 链式调用then() 返回一个新的 Promise 实例，这就是 Promise 可以链式调用的原因 2.2 Promise.prototype.catch()是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 若 .then(null, rejection) 指定和 .catch() 都存在，则执行先出现的。 如果将 .catch 放在 .then 前，要是then()方法里面报错，就与前面的catch()无关了。 123456789101112131415161718const promiseErr = new Promise(function(resolve, reject) { reject(new Error('test'));});promiseErr.then(()=&gt;{}, (err)=&gt;{ console.log('reject',err)}).catch(function(error) { console.log('catch',error);});// 输出// reject Error: testpromiseErr.catch(function(error) { console.log('catch',error);}).then(()=&gt;{}, (err)=&gt;{ console.log('reject',err)})// 输出// catch Error: test 2.3 Promise.prototype.finally() finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 不依赖于 Promise 的执行结果。 写在前面就会先执行（仍是微任务） 1234567891011const promiseFin = new Promise(function(resolve, reject) { resolve('success');});promiseFin.finally(() =&gt; { console.log('finally')}).then((res)=&gt;{ console.log(res)})// 输出:// finally // success 3. 构造函数方法3.1 Promise.resolve()将现有对象转为 Promise 对象， **Promise.resolve(value)**方法返回一个以给定值解析后的 Promise 对象。 123456const promise1 = Promise.resolve(123);promise1.then((value) =&gt; { console.log(value); // expected output: 123}); 3.2 Promise.reject()将现有对象转为 Promise 对象， Promise.reject() 方法返回一个带有拒绝原因的 Promise 对象。 3.3**Promise.all([ p1, p2, p3, ...])**【只要有 rejected，状态都变为 rejected】 Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。只要有一个 rejected，状态都变为 rejected。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成****fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 1234567var p1 = new Promise((resolve, reject) =&gt; { console.log('hello p1');resolve('hello');})var p2 = new Promise((resolve, reject) =&gt; { console.log('hello p2');resolve('hellooo');})var p = Promise.all([p1,p2]) 只要p1、p2、p3之中有一个被rejected，p的状态就变成****rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.all() 是所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。 1234567var p1 = new Promise((resolve, reject) =&gt; { console.log('hello p1');reject('hello');})var p2 = new Promise((resolve, reject) =&gt; { console.log('hello p2');resolve('hellooo');})var p = Promise.all([p1,p2]) 3.4 Promise.allSettled()【用来确定一组异步操作是否都结束了（不管成功或失败）】 同上的例子，用 Promise.all() 返回的状态是 reject； 用 Promise.allSettled() 返回的状态是 fulfilled； 1234567var p1 = new Promise((resolve, reject) =&gt; { console.log('hello p1');reject('hello');})var p2 = new Promise((resolve, reject) =&gt; { console.log('hello p2');resolve('hellooo');})var p = Promise.allSettled([p1,p2]) 3.5 Promise.race()【取率先改变的状态】 Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 3.6 Promise.any() 【任意一个成功就算成功，全部失败才是失败】 只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 想要刷題可看这个： https://juejin.cn/post/6844904077537574919 参考： https://es6.ruanyifeng.com/#docs/promise","link":"/401-Promise/"},{"title":"Vue实例初始化","text":"【前情回顾】 1234// src/core/index.jsimport Vue from './instance/index'...export default Vue src/core/instance/index.js 创建 new Vue(options) 时调用的方法，内部 调用 _init 方法 挂载 初始化 相关方法 挂载 状态处理 相关方法 挂载 事件 相关方法 挂载 生命周期 方法 挂载 渲染 相关方法 12345678910111213141516171819202122232425262728// src/core/instance/index.jsimport { initMixin } from './init'import { stateMixin } from './state'import { renderMixin } from './render'import { eventsMixin } from './events'import { lifecycleMixin } from './lifecycle'import { warn } from '../util/index'// 组件创建 new Vue() 时调用的方法// options是new Vue() 时传的配置项参数，如data、methods等function Vue (options) { // 当 直接使用 Vue(...) 时会报错，要求用 new Vue(...) if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}initMixin(Vue) // 挂载 初始化 方法 ( 含 this._init )stateMixin(Vue) // 挂载 状态处理 方法eventsMixin(Vue) // 挂载 事件 相关方法lifecycleMixin(Vue) // 挂载 生命周期 方法renderMixin(Vue) // 挂载 渲染 相关方法export default Vue 1. initMixin(Vue) 定义 Vue.prototype._init ，代码分析如下 6 1234// src/core/instance/init.jsexport function initMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._init = function (options?: Object) {...}} 2. stateMixin(Vue) 给 Vue 挂载属性 $data $props $set $delete $watch 12345678910111213141516171819202122232425262728293031323334// src/core/instance/state.js...import Watcher from '../observer/watcher'import Dep, { pushTarget, popTarget } from '../observer/dep'import { set, del, observe, defineReactive, toggleObserving} from '../observer/index'...export function stateMixin (Vue: Class&lt;Component&gt;) { ... Object.defineProperty(Vue.prototype, '$data', dataDef) Object.defineProperty(Vue.prototype, '$props', propsDef) Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object ): Function { ... const watcher = new Watcher(vm, expOrFn, cb, options) ... return function unwatchFn () { watcher.teardown() } }} 3. *eventsMixin*(*Vue*) 给 Vue 挂载属性 $on``$once``$off $emit 1234567// src/core/instance/events.jsexport function eventsMixin (Vue: Class&lt;Component&gt;) { Vue.prototype.$on = function(){...} Vue.prototype.$once = function(){...} Vue.prototype.$off = function(){...} Vue.prototype.$emit = function(){...}} 4. *lifecycleMixin*(*Vue*) 给 Vue 挂载属性 $_update``$forceUpdate``$destroy 123456// src/core/instance/lifecycle.jsexport function eventsMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._update = function(){...} Vue.prototype.$forceUpdate = function(){...} Vue.prototype.$destroy = function(){...}} 5. *renderMixin*(*Vue*) 给 Vue 挂载属性 $nextTick``_render 123456// src/core/instance/render.jsexport function eventsMixin (Vue: Class&lt;Component&gt;) { Vue.prototype.$nextTick = function(){...} Vue.prototype._render = function(){...} Vue.prototype.$destroy = function(){...}} 6. this._init() 初始化 Vue 实例 vm 的属性 _uid ,_isVue, $option, _renderProxy,_name 等 ； beforeCreate 前， 合并参数及组件； 开发环境且支持 Proxy 对象的，使用 initProxy 拦截检测实例 vm 初始化生命周期的状态变量，如 $parent, $child, _watcher, _isMounted 等 初始化事件变量 $_events 初始化渲染相关变量，如 $slot, _c, $createElement, $attrs, $listeners 等 beforeCreate 后，created 前， 初始化注入元素 初始化状态， props, methods, data, computed, watch 初始化提供注入的数据或方法 created后，vm.$mount 挂载 el 元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// src/core/instance/init.jsexport function initMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._init = function (options?: Object) { // Vue 实例 const vm: Component = this // a uid // 在 Vue 的源码中每一个类型的实例 都会有一个 唯一标识 vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { startTag = `vue-perf-start:${vm._uid}` endTag = `vue-perf-end:${vm._uid}` mark(startTag) } // a flag to avoid this being observed // Vue 根实例的标记，用于避免 被响应式处理的标记 vm._isVue = true // merge options 合并参数 if (options &amp;&amp; options._isComponent) { // 组件的合并 // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { // 简单实例的合并，将自定义属性和默认属性合并 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } /* istanbul ignore else */ // 开发环境时，调用 initProxy 方法 // 如果不是开发环境，则将 vue实例的 _renderProxy 属性指向 vue实例本身 if (process.env.NODE_ENV !== 'production') { initProxy(vm) } else { vm._renderProxy = vm } // expose real self // 将实例指向 _self 属性 vm._self = vm // 初始化生命周期的状态变量 initLifecycle(vm) // 初始化事件 initEvents(vm) // 初始化创建元素的方法 initRender(vm) // 标记生命周期 - beforeCreate callHook(vm, 'beforeCreate') // 初始化注入元素 initInjections(vm) // resolve injections before data/props // 初始化状态（data，props）【重点】 initState(vm) // 初始化注入对应的依赖 initProvide(vm) // resolve provide after data/props // 标记生命周期 - created callHook(vm, 'created') /* istanbul ignore if */ // 给 performance 分析添加处理标记 if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue ${vm._name} init`, startTag, endTag) } if (vm.$options.el) { // 组件挂载, 将组件挂载到 el 描述的元素上 // 此处的 $mount 方法 // 会先调用 扩展的 $mount 方法（src/platforms/web/entry-runtime-with-compiler.js）, 生成 render // 再调用 原始的 $mount 方法（src/platforms/web/runtime/index.js）, 获得元素, 再调用 mountComponent 方法 vm.$mount(vm.$options.el) } }} 6.1 initProxy(vm)详细分析见 04- initProxy 6.2 initLifecycle(vm) 初始化 生命周期 相关属性，如 $root, $refs, $children, _watcher, _isMounted, _destroyed 123456789101112131415161718192021222324252627282930// src\\core\\instance\\lifecycle.js/** * 初始化 生命周期 相关属性 */export function initLifecycle (vm: Component) { const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) { while (parent.$options.abstract &amp;&amp; parent.$parent) { parent = parent.$parent } parent.$children.push(vm) } vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = {} vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false} 6.3 initEvents(vm) 新增_events属性并将其赋值为空对象，用来存储事件 获取父组件注册的事件赋给listeners，如果listeners不为空，则调用updateComponentListeners函数，将父组件向子组件注册的事件注册到子组件的实例中 1234567891011121314151617181920212223242526272829303132333435363738// src\\core\\instance\\events.jslet target: anyfunction add (event, fn) { target.$on(event, fn)}function remove (event, fn) { target.$off(event, fn)}/** * 初始化 属性 _events, _hasHookEvent，增加更新组件监听 * @param {} vm */export function initEvents (vm: Component) { vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) { // 如果有 父组件监听，则 调用更新组件方法 updateComponentListeners(vm, listeners) }}export function updateComponentListeners ( vm: Component, listeners: Object, oldListeners: ?Object) { // 增加 绑定事件 方法 target = vm updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm) // 增加 移除事件方法 target = undefined} 6.3.1 updateListeners() 遍历 listeners , 如果 listeners对象中存在某个key（即事件名）而oldListeners中不存在，则说明这个事件是需要新增的； 遍历 oldListeners , 如果oldListeners对象中存在某个key（即事件名）而listeners中不存在，则说明这个事件是需要从事件系统中卸载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 对比listeners和oldListeners * 再通过 add 和remove 进行 注册事件 和 卸载事件 * @param {*} on * @param {*} oldOn * @param {*} add * @param {*} remove * @param {*} createOnceHandler * @param {*} vm */export function updateListeners ( on: Object, oldOn: Object, add: Function, remove: Function, createOnceHandler: Function, vm: Component) { let name, def, cur, old, event for (name in on) { def = cur = on[name] old = oldOn[name] event = normalizeEvent(name) ... /* export function isUndef (v: any): boolean %checks { return v === undefined || v === null } */ if (isUndef(cur)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Invalid handler for event &quot;${event.name}&quot;: got ` + String(cur), vm ) } else if (isUndef(old)) { // cur 有值， old 没值 if (isUndef(cur.fns)) { cur = on[name] = createFnInvoker(cur, vm) } if (isTrue(event.once)) { cur = on[name] = createOnceHandler(event.name, cur, event.capture) } // 调用入参的 target.$on(event, fn) 方法 注册事件 add(event.name, cur, event.capture, event.passive, event.params) } else if (cur !== old) { // cur 有值， old 有值，且两者不相等 old.fns = cur on[name] = old } } for (name in oldOn) { // 遍历旧Listener，如果有 name 属性没有值 if (isUndef(on[name])) { event = normalizeEvent(name) // 调用入参的 target.$off(event, fn) 方法 移除事件 remove(event.name, oldOn[name], event.capture) } }} 6.4 initRender(vm) 初始化 渲染相关属性，如 _node, _staticTrees, $slots, $scopedSlots, _c, $createElement 等 将 $attrs 和 $listeners 变成响应式 123456789101112131415161718192021222324252627282930313233343536373839// src\\core\\instance\\render.jsexport function initRender (vm: Component) { // _vnode 是子节点树的根 vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates // 系统创建元素的方法，参数分别为：tag, data, children, normalizationType, alwaysNormalize vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. // 用户写 render 属性时创建元素的方法 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ // 将 $attrs 和 $listeners 变成响应式 if (process.env.NODE_ENV !== 'production') { defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; { !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) }, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () =&gt; { !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) }, true) } else { defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true) }} 6.5 callHook(vm, 'beforeCreate') 执行 $options 中配置的钩子函数 若有 Hook Event（vm._hasHookEvent 为 true），生命周期函数执行后触发自定义hook事件 123456789101112131415161718192021222324252627/** * 执行 $options 中配置的钩子函数 * @param {*} vm * @param {*} hook */export function callHook (vm: Component, hook: string) { // #7573 disable dep collection when invoking lifecycle hooks // 当构造生命周期钩子时， 禁止 dep 依赖收集，故将 Dep.target 置空 pushTarget() // 从参数中获取 钩子函数体， 如created, mounted const handlers = vm.$options[hook] const info = `${hook} hook` if (handlers) { // 遍历钩子函数体，通过 apply 或 call 执行钩子函数体的内容 for (let i = 0, j = handlers.length; i &lt; j; i++) { invokeWithErrorHandling(handlers[i], vm, null, vm, info) } } // 若实例设置 Hook Event，如：&lt;comp @hook:mounted=&quot;method&quot; /&gt;， // 执行完生命周期函数之后，触发该事件的执行 if (vm._hasHookEvent) { // 相当于 vm.$emit('hook:mounted') vm.$emit('hook:' + hook) } // 关闭依赖收集 popTarget()} 6.5.1 invokeWithErrorHandling(handlers[i], vm, null, vm, info) 将 handler 函数体，包在 try catch 中捕获异常 执行 handler 函数 1234567891011121314151617181920212223242526272829303132333435// src\\core\\util\\error.js/** * 执行 handler 函数 * @param {*} handler * @param {*} context * @param {*} args * @param {*} vm * @param {*} info * @returns */export function invokeWithErrorHandling ( handler: Function, context: any, args: null | any[], vm: any, info: string) { let res try { // 若有参数 用 apply，若无则用 call，执行 handler 函数， // handler 方法体内若无return，则res 为 undefined（正常情况下为undefined） res = args ? handler.apply(context, args) : handler.call(context) if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) { // 当 返回有值 且 _isVue 不为true 且 是Promise 对象 且 _handled 为空即第一次执行的，报错 res.catch(e =&gt; handleError(e, vm, info + ` (Promise/async)`)) // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true } } catch (e) { handleError(e, vm, info) } return res} 6.6 initInjections(vm) 通过 resolveInject 方法处理 获取 $option.inject 参数中数组中 键 对应的 provide 的 键值对参数 若有 inject ，将处理后的参数进行响应式处理 挂到 vm 实例上 注意：解析 inject 在 初始化 data/props 之前 12345678910111213141516171819202122232425262728293031323334353637383940// src\\core\\instance\\inject.js/** * 将 $options.inject 的值注入到 vm 上 * @param {*} vm */export function initInjections (vm: Component) { // 获取 $options.inject 注入内容 /* 如： // 父组件 provide: { father: 'father params' }, // 子组件 inject: ['father'], result 结果为： {father: &quot;father params&quot;} */ const result = resolveInject(vm.$options.inject, vm) if (result) { // 关闭依赖收集监听 toggleObserving(false) // 将注入的值，在 vm 实例上直接响应式处理；使其可以直接用 vm.father 这种方式使用注入的值 Object.keys(result).forEach(key =&gt; { /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { defineReactive(vm, key, result[key], () =&gt; { warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: &quot;${key}&quot;`, vm ) }) } else { // 处理后 vm.father = &quot;father params&quot; defineReactive(vm, key, result[key]) } }) // 打开依赖收集监听 toggleObserving(true) }} 6.7 initState(vm) 初始化 props, methods, data, computed, watch 1234567891011121314151617181920212223242526272829// src\\core\\instance\\state.js/** * 初始化 props, methods, data, computed, watch * @param {*} vm */export function initState (vm: Component) { vm._watchers = [] const opts = vm.$options // 初始化 options.props 成员 if (opts.props) initProps(vm, opts.props) // 初始化 options.methods 方法成员 if (opts.methods) initMethods(vm, opts.methods) // 初始化 options.data ( 响应式处理 ) if (opts.data) { initData(vm) } else { observe(vm._data = {}, true /* asRootData */) } // 初始化 options.computed 计算属性 if (opts.computed) initComputed(vm, opts.computed) // 初始化 options.watch 监听 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) }} 6.7.1 initProps(vm,opts.props) 遍历 $options.props ，将 key 挂载在 vm._props 下，进行响应式处理 1234567891011121314151617181920212223242526272829303132333435// src\\core\\instance\\state.js/** * 初始化 props * @param {*} vm * @param {*} propsOptions */function initProps (vm: Component, propsOptions: Object) { const propsData = vm.$options.propsData || {} const props = vm._props = {} // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted // 不在根下，关闭响应式处理 if (!isRoot) { toggleObserving(false) } for (const key in propsOptions) { keys.push(key) const value = validateProp(key, propsOptions, propsData, vm) ... // 将 key 挂载在 vm._props 下，进行响应式处理 defineReactive(props, key, value) ... // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. // 如果 key 不在 vm 实例中，则 将 key 挂载到 vm._props 属性下 if (!(key in vm)) { proxy(vm, `_props`, key) } } toggleObserving(true)} 6.7.2 initMethods(vm,opts.methods) 遍历 $options.methods ，校验方法，若不是function类型、或与 props 重名、或方法名重名 均报错 若是方法，则 使用 bind 方法，将每个 methods 方法体的 this 指向 vm 实例 12345678910111213141516171819202122232425262728293031323334353637/** * 初始化 methods 所有方法 * @param {*} vm * @param {*} methods */function initMethods (vm: Component, methods: Object) { const props = vm.$options.props for (const key in methods) { if (process.env.NODE_ENV !== 'production') { // 校验 方法不是 function if (typeof methods[key] !== 'function') { warn( `Method &quot;${key}&quot; has type &quot;${typeof methods[key]}&quot; in the component definition. ` + `Did you reference the function correctly?`, vm ) } // 校验 方法 与 props 重名 if (props &amp;&amp; hasOwn(props, key)) { warn( `Method &quot;${key}&quot; has already been defined as a prop.`, vm ) } // 校验 方法名重复 if ((key in vm) &amp;&amp; isReserved(key)) { warn( `Method &quot;${key}&quot; conflicts with an existing Vue instance method. ` + `Avoid defining component methods that start with _ or $.` ) } } // 若 methods[key] 不是方法，则 值为空函数 // 若 是方法，相当于 methods[key].bind(vm)，即将每个 methods 方法体的 this 指向 vm 实例 vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm) }} 【辅助】bind12345678910// src\\shared\\util.js// 支持 bind 时， 即将 fn 内的 this 指向 ctxfunction nativeBind (fn: Function, ctx: Object): Function { return fn.bind(ctx)}export const bind = Function.prototype.bind ? nativeBind : polyfillBind 6.7.3 initData(vm) method、props 重名校验 循环遍历，将 $options.data 的属性挂载到 vm._data；为方便访问，又将其直接挂载到 vm 下 调用 observe 响应式处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// src\\core\\instance\\state.jsfunction initData (vm: Component) { let data = vm.$options.data // data 如果是对象格式，则直接赋值；若是函数，则通过getData 获取data 对象 // 然后将 data 挂载到 vm._data 上 data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] // methods 与 $options.data 属性不能重名 if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn( `Method &quot;${key}&quot; has already been defined as a data property.`, vm ) } } // props 与 $options.data 属性不能重名 if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property &quot;${key}&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { // 若不含保留字符 $ 和 _，循环将 $options.data 的所有属性 key 映射到 vue 实例上 // 从而访问 data中的属性时，不用 Vue._data.**，直接用 Vue.** proxy(vm, `_data`, key) } } // observe data // data 响应式处理 observe(data, true /* asRootData */)} 6.7.3.1 getData() 由于此时是 Vue 的初始化，还没有进行模板渲染，所以 不需要进行依赖收集，在 pushTarget 的时候传入 空 就将全局的 Watcher 设置为 undefined，依赖收集的时候有一个判断是 Dep.target 存在的时候才收集 12345678910111213export function getData (data: Function, vm: Component): any { // #7573 disable dep collection when invoking data getters // 此时是 Vue 的初始化，还没有进行模板渲染，所以 不需要进行依赖收集 pushTarget() try { return data.call(vm, vm) } catch (e) { handleError(e, vm, `data()`) return {} } finally { popTarget() }} 6.7.3.2 proxy() 将$options.data 的所有属性 key 映射到 vue 实例上12345678910111213// src\\core\\instance\\state.js// 通过 Object.defineProperty 数据劫持// eg：proxy(vm, `_data`, key), 实现将 vm._data.key 可以直接用 vm.key 访问的功能export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} 6.7.3.3 observe响应式处理详见 05- observer 6.7.4 initComputed(vm,opts.computed)详见 05- observer 的 6 6.7.5 initWatch(vm,opts.watch)详见 05- observer 的 5.1 6.8 initProvide(vm) 初始化 provide 指定我们想要提供给后代组件的数据/方法 12345678910111213/** * 初始化 provide * 获取 $options.provide，若是 function 则直接执行；若不是则返回 provide * @param {*} vm */export function initProvide (vm: Component) { const provide = vm.$options.provide if (provide) { vm._provided = typeof provide === 'function' ? provide.call(vm) : provide }} 6.9 vm.$mount(vm.$options.el)详细分析见 06- 模板渲染 参考： https://juejin.cn/post/6877754661362171912 https://juejin.cn/post/6954923081462710309 https://juejin.cn/post/7070087080965046280","link":"/102-Vue%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"全局API源码","text":"【前情回顾】 12345678910// src/core/index.js// 初始化 vue 实例import Vue from './instance/index'import { initGlobalAPI } from './global-api/index'...// 初始化 Vue 全局 APIinitGlobalAPI(Vue)...export default Vue 此文件主要是注册 Vue API 方法，因此比对着 官方API 读，会容易许多。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// core/global-api/index.jsexport function initGlobalAPI (Vue: GlobalAPI) { // ===== 1 ===== // config // 劫持 config 属性，根据warn提示，此处是为了保护 Vue.config， 不被同名替换 const configDef = {} configDef.get = () =&gt; config if (process.env.NODE_ENV !== 'production') { configDef.set = () =&gt; { warn( 'Do not replace the Vue.config object, set individual fields instead.' ) } } Object.defineProperty(Vue, 'config', configDef) // ===== 2 ===== // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. // 提示：这些不被认为是公共API的一部分，避免依赖它们，除非你清楚风险。 Vue.util = { warn, extend, mergeOptions, defineReactive } // ===== 3 ===== // 挂载 Vue.set, Vue.delete, Vue.nextTick 方法 Vue.set = set Vue.delete = del Vue.nextTick = nextTick // 挂载 Vue.observable(object) 方法 ， 2.6.0 新增方法 // 2.6 explicit observable API Vue.observable = &lt;T&gt;(obj: T): T =&gt; { observe(obj) return obj } // ===== 4 ===== /* export const ASSET_TYPES = [ 'component', 'directive', 'filter' ] */ // 初始化 Vue.options, Vue.options.directive, Vue.options.component, Vue.options.filter 方法 Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; { Vue.options[type + 's'] = Object.create(null) }) // ===== 5 ===== // this is used to identify the &quot;base&quot; constructor to extend all plain-object // components with in Weex's multi-instance scenarios. // 将 Vue 构造函数挂载到 _base 属性，多用于 weex 多应用场景 Vue.options._base = Vue // ===== 6 ===== // 挂载 keepAlive extend(Vue.options.components, builtInComponents) // ===== 7 ===== // 挂载 Vue.use, Vue.mixin, Vue.extend 方法 initUse(Vue) initMixin(Vue) initExtend(Vue) // ===== 8 ===== // 注册定义 Vue.directive, Vue.component, Vue.filter initAssetRegisters(Vue)} 1. Vue.config 全局配置 silent: 取消 Vue 所有的日志与警告。 optionMergeStrategies: 自定义合并策略的选项。(父实例和子实例参数合并时） devtools：配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler： 这个处理函数被调用时，可获取错误信息和 Vue 实例。 warnHandler： 为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。 ignoredElements： 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes： 给 v-on 自定义键位别名。 performance： 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。 productionTip： 如果设置为 false 以阻止 vue 在启动时生成生产提示。 2. Vue.util一些常用的内部 API 的挂载 3. Vue.set, Vue.delete,Vue.nextTick, Vue.observable3.1 Vue.set( target, propertyName/index, value )向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property 1234567891011121314151617181920212223242526272829303132333435363738394041// src\\core\\observer\\index.jsexport function set (target: Array&lt;any&gt; | Object, key: any, val: any): any { // 确保target是响应式对象中 if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target)) ) { warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`) } // 若target是数组，属性key在target中，则直接赋新值返回 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } // 属性key在target中，且不是在prototype上，说明此属性已存在，则直接赋新值返回 if (key in target &amp;&amp; !(key in Object.prototype)) { target[key] = val return val } const ob = (target: any).__ob__ // 是Vue组件，且 vmCount 在有 asRootData 时增加，vmCount 不等于 0 时说明在root下 // 说明应避免直接在 Vue 根root $data 下添加响应式属性 if (target._isVue || (ob &amp;&amp; ob.vmCount)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.' ) return val } // target 没有 __ob__ 说明是一个非响应式对象，直接添加普通属性 if (!ob) { target[key] = val return val } // 设置响应式 defineReactive(ob.value, key, val) // 并在更新 dep ob.dep.notify() return val} 3.2 Vue.delete( target, propertyName/index )删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。 在 2.2.0+ 中同样支持在数组上工作。 目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。 12345678910111213141516171819202122232425262728293031// src\\core\\observer\\index.jsexport function del (target: Array&lt;any&gt; | Object, key: any) { if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target)) ) { warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`) } if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) { target.splice(key, 1) return } const ob = (target: any).__ob__ // 目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。 if (target._isVue || (ob &amp;&amp; ob.vmCount)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.' ) return } // 不存在则不删 if (!hasOwn(target, key)) { return } delete target[key] // 如果是非响应式对象，则不用同步修改 dep if (!ob) { return } ob.dep.notify()} 3.3 [Vue.nextTick( callback, context] )在下次 DOM 更新循环结束之后执行延迟回调。 在修改数据之后立即使用这个方法，获取更新后的 DOM。 整个流程： 将调用 nextTick 的参数都放在数组 callbacks 中存下，同时将 pending 标志位改为 true，并开启一个宏/微任务挂起。 当挂起的 callbacks 正在执行，又有新的 nextTick 调用，将新任务存到 callbacks 队列中 当执行任务 flushCallbacks ，重置 callbacks，pending，遍遍历 callbacks ，执行回调函数 具体可见 07- nextTick 3.4 Vue.observable( object )让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。 内部调用 observe(obj)实现 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。 也可以作为最小化的跨组件状态存储器，eg如下： 123456789101112131415161718192021222324252627282930313233343536373839404142// src\\core\\observer\\index.js/** * In some cases we may want to disable observation inside a component's * update computation. */// 是否启用观察的标记位export let shouldObserve: boolean = trueexport function toggleObserving (value: boolean) { shouldObserve = value}/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void { // 如果不是对象，或者是 VNode，则不进行响应处理 if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void // 若本身就是响应式对象则 ob = value.__ob__ if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { // 可响应处理的标志 &amp;&amp; 不是SSR &amp; (数组 || 对象) &amp; 对象可扩展 &amp; 不是 Vue 实例本身 ob = new Observer(value) } if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob} **Object.isExtensible()**Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性） _isVue_isVue 为 ture 时，是初始化_init()时赋值，表示 Vue 本身的标志 1234// src\\core\\instance\\init.js // a flag to avoid this being observed vm._isVue = true 4. 初始化对象初始化 Vue.options, Vue.options.directive, Vue.options.component, Vue.options.filter 方法 具体细节见 8 5. Vue.options._base = VueVue 挂载 _base 6.extend(Vue.options.components, builtInComponents)拆解此方法后知，此方法是初始化构建 KeepAlive 组件，将 KeepAlive 组件挂载到 Vue.option.components 。 https://cn.vuejs.org/v2/api/#keep-alive 6.1 extend()引用自： import { initExtend } from'./extend' 由此引用，找到实际定义的文件： src\\shared\\util.js 12345678910/** * Mix properties into target object. * 将 _from 的属性混入到 to 中，并返回新的原对象to */export function extend (to: Object, _from: ?Object): Object { for (const key in _from) { to[key] = _from[key] } return to} 6.2 builtInComponents引用于 import builtInComponents from '../components/index'' 123456// src\\core\\components\\index.jsimport KeepAlive from './keep-alive'export default { KeepAlive} keep-alive 组件源码分析可参考： https://juejin.cn/post/6844903837770203144#heading-3 Vue渲染的整个过程： Vue的渲染是从图中的render阶段开始的，但keep-alive的渲染是在patch阶段，这是构建组件树（虚拟DOM树），并将VNode转换成真正DOM节点的过程。 7. Vue.use, Vue.mixin, Vue.extend7.1 Vue.use( plugin )安装 Vue.js 插件。 1234567891011121314151617181920212223242526// src\\core\\global-api\\use.jsexport function initUse (Vue: GlobalAPI) { Vue.use = function (plugin: Function | Object) { const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) // 若插件存在则直接返回，不重复添加 // 当 install 方法被同一个插件多次调用，插件将只会被安装一次 if (installedPlugins.indexOf(plugin) &gt; -1) { return this } // additional parameters // install 方法调用时，会将 Vue 作为参数传入 const args = toArray(arguments, 1) args.unshift(this) // 如果插件是一个对象，必须提供 install 方法 if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args) } else if (typeof plugin === 'function') { // 如果插件是一个函数，它会被作为 install 方法 plugin.apply(null, args) } installedPlugins.push(plugin) return this }} 7.2 Vue.mixin( mixin ) 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。 123456789// src\\core\\global-api\\mixin.jsexport function initMixin (Vue: GlobalAPI) { Vue.mixin = function (mixin: Object) { // 合并参数 this.options = mergeOptions(this.options, mixin) return this }} 7.3 Vue.extend( options )使用基础 Vue 构造器，创建一个“子类”。 参数是一个包含组件选项的对象。 data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 应用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// src\\core\\global-api\\extend.js Vue.extend = function (extendOptions: Object): Function { extendOptions = extendOptions || {} const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {}) // cid 是每个组件的唯一标志，若已创建则直接返回 if (cachedCtors[SuperId]) { return cachedCtors[SuperId] } const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== 'production' &amp;&amp; name) { validateComponentName(name) } // Sub 就是使用 一个包含组件选项的对象 的参数，初始化创建一个 Vue 组件 const Sub = function VueComponent (options) { this._init(options) } // 继承父的prototype Sub.prototype = Object.create(Super.prototype) // 指向自己的 constructor Sub.prototype.constructor = Sub Sub.cid = cid++ // 合并父的参数 Sub.options = mergeOptions( Super.options, extendOptions ) Sub['super'] = Super // For props and computed properties, we define the proxy getters on // the Vue instances at extension time, on the extended prototype. This // avoids Object.defineProperty calls for each instance created. // 对于 props 和 computed 属性，定义proxy 的 getters 时扩展到Vue 实例的prototype 上，这样可以避免创建每个实例都调用 Object.defineProperty // 此句扩展的体现在 initProps(Sub) 的实现上， proxy(Comp.prototype, `_props`, key) ，用的是Comp.prototype if (Sub.options.props) { initProps(Sub) } if (Sub.options.computed) { initComputed(Sub) } // allow further extension/mixin/plugin usage Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) { Sub[type] = Super[type] }) // enable recursive self-lookup if (name) { Sub.options.components[name] = Sub } // keep a reference to the super options at extension time. // later at instantiation we can check if Super's options have // been updated. Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend({}, Sub.options) // cache constructor cachedCtors[SuperId] = Sub return Sub }} 8. initAssetRegisters(Vue)在第 4 部分，初始化 Vue.use, Vue.mixin, Vue.extend 对象； 12345678910111213141516171819202122232425262728293031323334353637383940// src\\core\\global-api\\assets.jsexport function initAssetRegisters (Vue: GlobalAPI) { /** * Create asset registration methods. * 注册方法 */ ASSET_TYPES.forEach(type =&gt; { Vue[type] = function ( id: string, definition: Function | Object ): Function | Object | void { // 无 definition 参数，直接返回已注册的 过滤器/指令/组件 if (!definition) { return this.options[type + 's'][id] } else { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') { // 注册组件，检查组件名是否规范 validateComponentName(id) } if (type === 'component' &amp;&amp; isPlainObject(definition)) { // 未设置 组件的name，则用id 当作name definition.name = definition.name || id // 若是组件，definition 为对象，则添加到 _base 中 // 注册组件，传入一个选项对象 (自动调用 Vue.extend) —— 针对官方 api 此句的处理 definition = this.options._base.extend(definition) } // 注册 (指令函数) if (type === 'directive' &amp;&amp; typeof definition === 'function') { // 这里将会被 `bind` 和 `update` 调用 —— 针对此的处理 definition = { bind: definition, update: definition } } this.options[type + 's'][id] = definition // 返回处理后的值 return definition } } })} 8.1 Vue.directive( id, [definition] )12345678910111213141516// 注册Vue.directive('my-directive', { bind: function () {}, inserted: function () {}, update: function () {}, componentUpdated: function () {}, unbind: function () {}})// 注册 (指令函数)Vue.directive('my-directive', function () { // 这里将会被 `bind` 和 `update` 调用})// getter，返回已注册的指令var myDirective = Vue.directive('my-directive') 8.2 Vue.filter( id, [definition] )1234567// 注册Vue.filter('my-filter', function (value) { // 返回处理后的值})// getter，返回已注册的过滤器var myFilter = Vue.filter('my-filter') 8.3 Vue.component( id, [definition] )12345678// 注册组件，传入一个扩展过的构造器Vue.component('my-component', Vue.extend({ /* ... */ }))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component('my-component', { /* ... */ })// 获取注册的组件 (始终返回构造器)var MyComponent = Vue.component('my-component')","link":"/103-%E5%85%A8%E5%B1%80API%E6%BA%90%E7%A0%81/"},{"title":"observer/Dep/Watcher","text":"1. Observer【前情回顾】 observe() 方法路径：src\\core\\observer\\index.js 123456789101112131415161718192021222324// src\\core\\instance\\index.jsfunction Vue (options) { this._init(options)}// src\\core\\instance\\init.jsexport function initMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._init = function (options?: Object) { initState(vm) }}// src\\core\\instance\\state.jsexport function initState (vm: Component) { if (opts.data) { initData(vm) } else { observe(vm._data = {}, true /* asRootData */) }}function initData (vm: Component) { let data = vm.$options.data observe(data, true /* asRootData */)} 1.1 observe()对 vm.$options.data 进行响应式处理的入口方法。 核心就是对符合响应式条件的 value 创建 new Observer 实例。 流程： 若 value （vm.options.$data）不是对象或是 Vnode 的实例，则不处理直接 return 若 value 包含属性__ob__，且value.__ob__是 Observer 的实例 (__ob__是 Vue 中响应式对象的 标记 )，则返回已存在的响应式对象 若没有包含__ob__, 则调用 new Observer(value)，创建 响应式对象 实例 123456789101112131415161718192021222324252627282930313233// src\\core\\observer\\index.js/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. * 为 vm.$options.data 创建一个 observer 实例 * 如果是可响应式的，则返回一个新实例；若已经存在则返回已有实例 */export function observe (value: any, asRootData: ?boolean): Observer | void { // 如果不是对象，或者是 VNode，则不进行响应处理 if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void // 若本身就是响应式对象则直接返回该实例 value.__ob__ if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { // 符合 可响应处理的标志 &amp;&amp; 不是SSR &amp; (数组 || 对象) &amp; 对象可扩展 &amp; 不是 Vue 实例本身，则进行响应式处理 ob = new Observer(value) } // 每个组件只能有一个根元素，若多个则标记，后续判断时有警告 if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob} 1.1.1 new Observer(value)创建响应式实例， 流程： 初始化 value，dep，__ob__，vmCount 若 value 是数组，先对数组原型方法进行响应式处理，再遍历递归至对象，再响应式处理 若 value 是对象，则直接 调用 defineReactive() 进行响应式处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// src\\core\\observer\\index.jsexport class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value // 相当于 this.value = vm.options.$data this.dep = new Dep() // Dep 创建了 this.vmCount = 0 // 为0，说明是根实例只有一个，符合规范 def(value, '__ob__', this) // 相当于 value.__ob__ = this，循环引用: 对象.__ob__ // 数组的响应式处理 if (Array.isArray(value)) { // 判断浏览器是否支持 __prop__ // 对数组 原型方法 进行响应式处理！ if (hasProto) { // 相当于 value.__proto__ = arrayMethods protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } // 遍历递归数组的元素，对数组每一项进行递归响应式处理 this.observeArray(value) } else { // 遍历对象的属性, 进行响应式处理 this.walk(value) } } /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. * 遍历对象，循环进行响应式 defineReactive 处理 */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) // 响应式处理来了 } } /** * Observe a list of Array items. * 遍历递归数组，调用响应式方法 */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 【辅助】def12345678910111213// src\\core\\util\\lang.js/** * Define a property. * 相当于 obj.key = val */export function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, writable: true, configurable: true })} 【辅助】arrayMethodsarrayProto： Array 基础类型的原型 arrayMethods： arrayMethods 继承 arrayProto ，arrayMethods 的原型就是 arrayProto 。 12const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto) 运行出来是： 关于 Object.create()：Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。 试一个简单的例子， var ob = Object.create(arr) 就是将 arr 的值作为 新对象 ob 的原型。 12var arr = [1, 'a']var ob = Object.create(arr) 若 arr 重新赋值， ob 并不会跟着改变，说明此处是深拷贝，不是指向的引用值： 【对Array原型方法进行响应式处理】Array基本类型有pop, push, shift, unshift 等方法，对其进行响应式处理 12345678910// 在 constructor 构造函数中处理// 判断浏览器是否支持 __prop__// 对数组 原型方法 进行响应式处理！！if (hasProto) { // 相当于 value.__proto__ = arrayMethods protoAugment(value, arrayMethods)} else { copyAugment(value, arrayMethods, arrayKeys)} 使用的工具方法实现： 12345678910111213141516171819202122232425// helpers/** * Augment a target Object or Array by intercepting * the prototype chain using __proto__ * 数组的原型链修改, 从而使得数组变成响应式的 ( pop, push, shift, unshift, ... ) ！ */function protoAugment (target, src: Object) { /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */}/** * Augment a target Object or Array by defining * hidden properties. * 如果浏览器不支持就将这些方法直接混入到当前数组中, 属性访问元素 *//* istanbul ignore next */function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) { for (let i = 0, l = keys.length; i &lt; l; i++) { const key = keys[i] def(target, key, src[key]) }} 1.1.1.1 defineReactive() 响应式的实现调用处的 walk 方法中，是循环遍历 obj，然后将 obj 和 obj 中每一个 key 作为入参： 1defineReactive(obj, keys[i]) 流程： 通過 Object.getOwnPropertyDesccriptor 获取 obj.key 的属性描述 通过 Object.defineProperty 劫持 obj.key 属性，改写 get、set 方法 当模板填充 data 的属性值时，触发 get 方法，调用 dep.depend() ，收集依赖（收集 Watcher） 当 data 的属性值修改时，触发 set 方法，调用 dep.notify() ，派发更新 （通知所有依赖的 Watcher） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Define a reactive property on an Object. * 为对象定义一个 可响应式 的属性 */ export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // 创建 new Dep // Dep见 3 分析 const dep = new Dep() // 获取对象的属性描述 ( { enumerable: true, writable: true, ... } ) const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set // 若 get 方法未定义，则 val 没有值，就手动给 val 赋值 if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } // 递归子，val 是属性值，递归循环看是否还有子对象|数组 let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, // get 方法收集依赖 // 读取 某个属性，就触发 get 方法 get: function reactiveGetter () { // 如果已经定义 get 方法可以被继承下来, 不会丢失 const value = getter ? getter.call(obj) : val // 如果有 target 标识，则进行依赖收集 if (Dep.target) { // 收集依赖 （页面 template 中用到 data 中某个 key 时，就触发 get 方法，在 dep 收集对应的 Watcher） // 方法内分析见4.2 dep.depend() // 收集子属性 if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, // set 通知依赖 set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ // 如果数据没有发生变化 就不会进行派发更新 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { // 保证了如果已经定义的 set 方法可以被继承下来, 不会丢失 setter.call(obj, newVal) } else { val = newVal } // 对新值进行响应式化处理 childOb = !shallow &amp;&amp; observe(newVal) // 派发更新 // 修改数据，通知页面重新渲染 // 方法内分析见4.3 dep.notify() } })} 【辅助】Object.getOwnPropertyDescriptor(obj, prop)Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） eg: 123456789const object1 = { property1: 42};const descriptor1 = Object.getOwnPropertyDescriptor(object1, 'property1');console.log(descriptor1);// 结果：// &gt; Object { value: 42, writable: true, enumerable: true, configurable: true } 2. Dep2.1 new Dep()12345678910111213let uid = 0export default class Dep { // target 是 当前 Watcher static target: ?Watcher; id: number; // subs 是所有 Watcher 集合，通过 addSub() 添加 subs: Array&lt;Watcher&gt;; constructor () { this.id = uid++ this.subs = [] }} 2.2 depend()收集依赖，通知 Watcher （通过调用 Watcher.addDep）收集依赖 123456// 收集依赖，通知 Watcher 收集depend () { if (Dep.target) { Dep.target.addDep(this) }} 2.3 addSub()实际 Dep 收集 Watcher 的方法，将Watcher 存到 subs 数组中 1234// 收集 Watcher，通过 dep.depend() ==&gt; Dep.target.addDep() ==&gt; dep.addSub()addSub (sub: Watcher) { this.subs.push(sub)} 2.4 notify()遍历通知 dep.subs 绑定的 Watcher ，更新视图 12345678910111213141516171819/** * 每一个属性 都会包含一个 dep 实例 * 这个 dep 实例会记录下 参与计算或渲染的 watcher */// 发送通知notify () { // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) { // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) } for (let i = 0, l = subs.length; i &lt; l; i++) { // 调用对应的 Watcher，更新视图 subs[i].update() }} 2.5 pushTarget()，popTarget()123456789101112131415161718192021/** * 在 watcher 调用 get 方法的时候, 调用 pushTarget(this)，将 Wather 赋值给 Dep.target * 在 watcher 的 get 方法结束的时候, 调用 popTarget()，将 Wather 重置为上一个 target */// The current target watcher being evaluated.// This is globally unique because only one watcher// can be evaluated at a time.// 全局的容器存储渲染 WatcherDep.target = nullconst targetStack = []// 将当前操作的 watcher 存储到 全局 watcher 中, 参数 target 就是当前 watcherexport function pushTarget (target: ?Watcher) { targetStack.push(target) Dep.target = target}// 将 当前 watcher 删掉，重置为上一个export function popTarget () { targetStack.pop() Dep.target = targetStack[targetStack.length - 1]} 3. Watcher 【前情】 12345678// src\\core\\instance\\state.jsexport function initState (vm: Component) { ... // 初始化 options.watch 监听 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) }} 3.1 Wather初始化1**initWatch(vm, opts.watch)** 遍历 $options.watch，值为数组的继续遍历， 1234567891011121314151617181920// src\\core\\instance\\state.js/** * 遍历 $options.watch, 调用 createWatcher 创建 * @param {*} vm * @param {*} watch */function initWatch (vm: Component, watch: Object) { // 遍历 $options.watch for (const key in watch) { const handler = watch[key] if (Array.isArray(handler)) { for (let i = 0; i &lt; handler.length; i++) { createWatcher(vm, key, handler[i]) } } else { createWatcher(vm, key, handler) } }} 3.1.1 createWatcher(vm, key, handler)1234567891011121314151617181920212223242526// src\\core\\instance\\state.js/** * 扩展 $watch * @param {*} vm * @param {*} expOrFn * @param {*} handler * @param {*} options * @returns */function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object) { // 如果是对象，参数移位 if (isPlainObject(handler)) { options = handler handler = handler.handler } // 如果是字符串，取 vm[handler] 作为方法 if (typeof handler === 'string') { handler = vm[handler] } return vm.$watch(expOrFn, handler, options)} 3.1.1.1 vm.$watch(expOrFn, handler, options)12345678910111213141516171819202122232425262728// src\\core\\instance\\state.js Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object ): Function { const vm: Component = this // 如果传入的 handler 是对象，则再扩展解析 if (isPlainObject(cb)) { return createWatcher(vm, expOrFn, cb, options) } options = options || {} options.user = true // 创建 Watcher 实例 !!! const watcher = new Watcher(vm, expOrFn, cb, options) // 如果 立即执行标志位为 true，则直接执行 handler（cb）函数 if (options.immediate) { const info = `callback for immediate watcher &quot;${watcher.expression}&quot;` pushTarget() invokeWithErrorHandling(cb, vm, [watcher.value], vm, info) popTarget() } // 返回取消监听函数 return function unwatchFn () { watcher.teardown() } } 3.2 new Watcher()3.2.1 construcor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// src\\core\\observer\\watcher.jslet uid = 0/** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. */// 在 Vue 中使用了 二次提交的概念// 每次在数据 渲染 或 计算的时候 就会访问响应式的数据, 就会进行依赖收集// 将关联的 Watcher 与 dep 相关联,// 在数据发生变化时, 根据 dep 找到关联的 Watcher, 遍历调用 update// 执行完成后会清空 Watcherexport default class Watcher { vm: Component; expression: string; // 关联表达式 或 渲染方法体 cb: Function; // 在定义 Vue 构造函数时，Vue.prototype.$watch id: number; deep: boolean; // 为 true 时，监听对象内部值的变化 user: boolean; lazy: boolean; // 计算属性标记，为 true 时 Watcher 不立即执行 sync: boolean; dirty: boolean; // 计算属性时，为 true 时，需重新计算 active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; // Watcher 触发之前, 类似于 生命周期 getter: Function; // 就是 渲染函数 ( 模板或组件的渲染 ) 或 计算函数 ( watch ) value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm if (isRenderWatcher) { vm._watcher = this } vm._watchers.push(this) // options if (options) { this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync this.before = options.before } else { this.deep = this.user = this.lazy = this.sync = false } this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter // expOrFn 如果是函数 if (typeof expOrFn === 'function') { // 在 mountComponent 中， // updateComponent = () =&gt; { // vm._update(vm._render(), hydrating) // } // new Watcher(vm, updateComponent); // 所以，这里的 expOrFn 是： /* ƒ () { vm._update(vm._render(), hydrating); } */ this.getter = expOrFn } else { this.getter = parsePath(expOrFn) if (!this.getter) { this.getter = noop process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: &quot;${expOrFn}&quot; ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) } } // 不是计算属性，则 调用 get() 初始化取值 this.value = this.lazy ? undefined : this.get() }} 3.2.2 get() 先 pushTarget(this) ，将当前 Watcher 赋值给 Dep.target 执行 this.getter 的方法 若 new Watcher() 的 在初始化 mountComponent 时，getter 是 f() {vm._update(vm._render(), hydrating); } 若 在 计算属性时，getter 是 $options.computed 遍历的某一项的自定义函数 popTarget() 和 cleanupDeps() 清除 Dep.tartget ，清除依赖收集 123456789101112131415161718192021222324252627282930313233343536/** * Evaluate the getter, and re-collect dependencies. * 计算的getter，重新收集依赖 */get () { // 将 当前 Watcher 赋值给 Dep.target pushTarget(this) let value const vm = this.vm try { // 如果 this.getter 是函数，则是 /* ƒ () { vm._update(vm._render(), hydrating); } */ // this.getter 就是 expOrFn，也就是 vm._render // vm._render 用来生成虚拟 dom、执行 dom-diff、更新真实 dom value = this.getter.call(vm, vm) } catch (e) { if (this.user) { handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`) } else { throw e } } finally { // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching // 若 要监听对象内部值，则递归 if (this.deep) { traverse(value) } popTarget() this.cleanupDeps() } return value} 3.2.3 run() 调用 get()，相当于执行 watcher.getter 的函数 执行 watcher.cb 函数 12345678910111213141516171819202122232425262728293031/** * Scheduler job interface. * Will be called by the scheduler. * 调用 get()，执行 watcher.cb 函数 */run () { if (this.active) { // 和初始化一样，直接调用 get(), 更新视图 const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) { // set new value const oldValue = this.value this.value = value // 执行 watcher 的 cb 回调函数 if (this.user) { // 如果是 user watchers，调用 invokeWithErrorHandling 执行 cb const info = `callback for watcher &quot;${this.expression}&quot;` invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info) } else { this.cb.call(this.vm, value, oldValue) } } }} 3.2.4 update()更新 Watcher 方法： 若是计算属性，则将 dirty 置为 true 若 sync 为 true，直接调用 run() 否则，调用 queueWatcher，开启异步队列（异步队列相关，见 3.3 scheduler ） 12345678910111213141516171819/** * Subscriber interface. * Will be called when a dependency changes. * 订阅者接口，在依赖项改变时被调用 */update () { /* istanbul ignore else */ if (this.lazy) { // 若是计算属性，更新后需将缓存标记置为true表示需要更新 this.dirty = true } else if (this.sync) { // 若为同步，直接 run this.run() } else { // 否则，放到 观察值队列 // 开启异步队列，批量更新 Watcher queueWatcher(this) }} 3.2.5 addDep(dep) 将 dep 添加到 watcher.newDeps 中 调用 dep.addSub(this)，再将 watcher 添加到 Dep 中 123456789101112131415161718/** * Add a dependency to this directive. * Watcher 关联 dep ， 并通知 dep 关联对应的 Watcher */addDep (dep: Dep) { const id = dep.id // 当前 dep 不在 新newDepIds 队列，就添加dep 及 id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) // 将 dep 关联到 Watcher 中的 newDeps this.newDeps.push(dep) // 当前 新id 不在 旧depIds 队列，同时将 Watcher 添加到 Dep 队列 if (!this.depIds.has(id)) { // 将 当前 Watcher 添加到 Dep.subs 中 dep.addSub(this) } }} 3.2.6 cleanupDeps()123456789101112131415161718192021/** * Clean up for dependency collection. * 清除依赖收集 ，清除当前watcher对应的 dep.subs 和 watcher.newDeps 中的对应关系 */cleanupDeps () { let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0} 3.2.7 evaluate()123456789101112/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. *//** * 计算 watcher 的值，仅用于 计算属性 */evaluate () { // 调用get() 方法重新计算 this.value = this.get() this.dirty = false} 3.2.7 depend()12345678910/** * Depend on all deps collected by this watcher. * 依赖收集；遍历 watcher 中存的 deps，挨个调 Dep.depend()，将watcher 与 dep 相互绑定 */depend () { let i = this.deps.length while (i--) { this.deps[i].depend() }} 3.2.8 teardown()123456789101112131415161718192021 /** * Remove self from all dependencies' subscriber list. * teardown 与 depend 相对 * 将当前 watcher 与 dep 的相互绑定关系移除 */ teardown () { if (this.active) { // remove self from vm's watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. if (!this.vm._isBeingDestroyed) { remove(this.vm._watchers, this) } let i = this.deps.length while (i--) { this.deps[i].removeSub(this) } this.active = false } }} 3.3 scheduler3.3.1 scheduler 相关的全局变量1234567891011121314// src\\core\\observer\\scheduler.jsexport const MAX_UPDATE_COUNT = 100// watcher 异步队列const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: { [key: number]: ?true } = {}let circular: { [key: number]: number } = {}// waiting:false 未开启异步队列（是在调用异步回调方法时开启的）let waiting = false// flushing: false 未开启冲洗队列（冲洗是在异步回调方法执行完成后回调时执行 flushSchedulerQueue 开启的）let flushing = falselet index = 0 waiting 与 flushing 区别： waiting 是为了判断当前是否调用异步队列 nextTick ，防止重复调用 flushing 是为了判断当前是否正在进行冲洗操作（冲洗操作是在异步队列 nextTick 执行后回调的方法） 3.3.2 queueWatcher()在 Watcher 的 update() 方法中调用。 先 判断队列中是否 新watcher 的id，若有则不重复添加到队列；若无，进行后面操作 再判断 flushing， 若当前没有冲洗操作，则将 wather 直接push 到 queue 队列 若正在进行冲洗操作，则遍历 queue 队列，给当前的watcher 根据 id 找到合适的位置插入 判断 waiting， 若 当前没有已调用 异步队列 nextTick，则修改标记 waiting 置为 true，将冲洗操作传给异步队列 nextTick(flushSchedulerQueue) 12345678910111213141516171819202122232425262728293031323334353637export function queueWatcher (watcher: Watcher) { const id = watcher.id // 若 watcher 的 id 在全局变量 has 中已存在，则忽略 // 避免重复更新，提升效率 if (has[id] == null) { has[id] = true if (!flushing) { // 当前没有冲洗操作，将 watcher 插入到队列 queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. // 冲洗操作时，将新的watcher 遍历按 id 顺序插入到正确的位置 // 遍历队列，从队尾开始开始，按照 id 的大小（队列是从小到大的顺序）将 Watcher 插入到队列 // 如果没有遍历到，即当前 id 比队列中的id 都大，没有执行过 i--，相当于插入到队尾 // index 代表队列中当前正在执行的 Watcher 的位置，初始为 0 let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush // 正在调用异步队列标记，表示调用队列执行之前不允许重复调用 if (!waiting) { waiting = true // 开发环境若配置同步 则立即执行 if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) { flushSchedulerQueue() return } // 将待执行的调度任务加入异步队列 nextTick(flushSchedulerQueue) } }} 3.3.3 flushSchedulerQueue()传给异步队列 nextTick 的回调方法，在异步队列执行后回调时执行此方法 给 watcher 队列用 id 排序 遍历 watcher 队列，调用 watcher.run() ；更新 active，update 状态 重置状态标记 1234567891011121314151617181920212223242526/** * Flush both queues and run the watchers. * 传给异步队列 nextTick 的回调方法，在异步队列执行后回调时执行此方法 */function flushSchedulerQueue () { currentFlushTimestamp = getNow() // 开始冲洗，此方法是在执行异步队列执行后的回调方法 flushing = true let watcher, id // 给队列用 id 由小到大排序 queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers // 执行 watcher.run()；更新 active，update 状态 for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] ... watcher.run() ... } ... resetSchedulerState() ...} 3.3.4 resetSchedulerState()123456789101112/** * Reset the scheduler's state. * 重置任务调度所有状态 */function resetSchedulerState () { index = queue.length = activatedChildren.length = 0 has = {} if (process.env.NODE_ENV !== 'production') { circular = {} } waiting = flushing = false} 4. computed 计算属性 initComputed(vm,opts.computed) 创建 计算属性内部的 watcher， vm._computedWatchers 为 计算属性 响应式处理 【lazy】计算属性标记：为true ，则为 计算属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// src\\core\\instance\\state.js// 计算属性的标记 lazy: trueconst computedWatcherOptions = { lazy: true }function initComputed (vm: Component, computed: Object) { // $flow-disable-line // 创建 存储计算属性 的 watcher：_computedWatchers const watchers = vm._computedWatchers = Object.create(null) // computed properties are just getters during SSR const isSSR = isServerRendering() for (const key in computed) { // 获取用户自定义的 computed const userDef = computed[key] // 兼容 computed 后直接写 方法 or 对象中写 get() 的方式 const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) { warn( `Getter is missing for computed property &quot;${key}&quot;.`, vm ) } // 在服务端SSR时，不创建计算属性对应 watcher if (!isSSR) { // create internal watcher for the computed property. // 为 计算属性 创建内部 watcher watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) } // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. // 如果计算属性 key 不在vue实例中，就创建响应式的 vm[key] ，其值为 userDef if (!(key in vm)) { defineComputed(vm, key, userDef) } else if (process.env.NODE_ENV !== 'production') { // 各种重名报错 if (key in vm.$data) { warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm) } else if (vm.$options.props &amp;&amp; key in vm.$options.props) { warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm) } else if (vm.$options.methods &amp;&amp; key in vm.$options.methods) { warn(`The computed property &quot;${key}&quot; is already defined as a method.`, vm) } } }} 为什么 SSR 不用创建 computed？由于watcher实现vue的响应式，而如果是服务器环境下，数据和模板从后端获取即可而不需要在前端收集依赖，不需要缓存机制，因此在服务器并不需要这一点 4.1 defineComputed(vm, key, userDef) 非 SSR 使用缓存，及 computed 的值是否是函数，设置get，set方法，进行响应式处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344// src\\core\\instance\\state.js// 响应式基础配置const sharedPropertyDefinition = { enumerable: true, configurable: true, get: noop, set: noop}.../** * computed 进行响应式处理 * @param {*} target * @param {*} key * @param {*} userDef */export function defineComputed ( target: any, key: string, userDef: Object | Function) { // 缓存标记，非 SSR 的进行缓存 const shouldCache = !isServerRendering() if (typeof userDef === 'function') { // userDef 若为函数，若有缓存用 createComputedGetter 转换，若无则用 createGetterInvoker 转换，获取 get sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef) sharedPropertyDefinition.set = noop } else { // userDef 若不是函数，则 取 userDef.get 的值 // 若userDef.get为空则赋值 空函数 // 若不为空，同上 if sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop sharedPropertyDefinition.set = userDef.set || noop } ... // computed 属性的 get，set 配置后，响应式 绑定 到 target[key] Object.defineProperty(target, key, sharedPropertyDefinition)} 4.1.1 createComputedGetter(key) 获取计算属性的watcher，_computedWatchers 若 watcher.dirty 为true，则调用 evaluate() 进行计算获取值；若为false，继续使用watcher.value 的缓存值 若 Dep.target 存在，则进行依赖收集 【dirty】：缓存标记；true：需要重新计算；false：使用缓存 12345678910111213141516171819/** * 返回计算属性的结果值 */function createComputedGetter (key) { return function computedGetter () { const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) { // dirty：缓存标记；true：需要重新计算；false：使用缓存 if (watcher.dirty) { watcher.evaluate() } // 依赖收集 if (Dep.target) { watcher.depend() } return watcher.value } }} 4.1.1.1 watcher.evaluate() 调用 watcher.get() 方法计算，并将 dirty 置为 false 123456789101112/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. *//** * 计算 watcher 的值，仅用于 计算属性 */evaluate () { // 调用get() 方法重新计算 this.value = this.get() this.dirty = false} 4.1.2 createGetterInvoker(userDef) SSR 下，直接返回 计算属性函数，不进行缓存处理 123456// 返回 直接执行 fn 的函数function createGetterInvoker(fn) { return function computedGetter () { return fn.call(this, this) }} 5. 响应式原理这位大神孟思行已经整理的非常好，直接拿来用好了 从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。 编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。 编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。 数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。 参考： https://juejin.cn/post/6844903858850758670https://juejin.cn/post/6857669921166491662","link":"/105-observer-Dep-Watcher/"},{"title":"模版渲染","text":"入口 vm.$mount 方法：在 vm.$mount(vm.$options.el)中， 1. 扩展 $mount 方法（platforms/web/entry-runtime-with-compiler）先调用 扩展的 $mount 方法（**src/platforms/web/entry-runtime-with-compiler.js**）, 生成 render。 id 不能挂载到 body 或 documentElement 页面文档上 若 this.$options 上没有 render 方法 取 $options 的 template 或 el 获取元素，生成 html 字符串（此 html 字符串即 下文 parseHTML 方法的入参 html） 调用 compileToFunctions ，获取 render 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// src/platforms/web/entry-runtime-with-compiler.jsconst mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { // 获取元素或查询元素 （query 方法分析见下方） // el 是元素选择器 el = el &amp;&amp; query(el) /* istanbul ignore if */ // vue 不允许将 id 直接挂到 body 或 页面文档 if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this } // 此处的 $options 如下图1 const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template // 若参数中有 template if (template) { if (typeof template === 'string') { // 若有 # ，则可能是id 选择器的标志，用 idToTemplate 转换获取 node 节点 if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { // 若 template 是node 类型节点，则取其 内部html 节点 template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { // 若el 有值，则取 el 本身元素（此处也表明 优先取 template 属性值） template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } /** * 1.模板编译，将 template 解析为 ast tree * 2.将 ast tree 转换成 render 语法字符串 * 3.生成 render 方法 **/ const { render, staticRenderFns } = compileToFunctions(template, { outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) // 这里的 render 就是生成虚拟 DOM 的方法 options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } // 此处转换后的 $options 如下图2 console.log(this.$options) // 由于是扩展方法，则 return 回 $mount 方法，使其继续调用原始方法 return mount.call(this, el, hydrating)} 【辅助】query(el) 方法：1234567891011121314151617181920/** * Query an element selector if it's not an element already. */export function query (el: string | Element): Element { // el 的格式只有 string 和 Element if (typeof el === 'string') { // string 时，相当于 el 的值是元素的 id ，通过 document.querySelector() 方法获取dom元素 ，并返回 const selected = document.querySelector(el) if (!selected) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Cannot find element: ' + el ) return document.createElement('div') } return selected } else { // 若是 Element 类型，直接返回 元素 return el }} 1.1 compileToFunctions() 找 compileToFunctions() 的定义在 src\\platforms\\web\\compiler\\index.js，由 createCompiler 创建 12345// src\\platforms\\web\\compiler\\index.jsimport { createCompiler } from 'compiler/index'const { compile, compileToFunctions } = createCompiler(baseOptions)export { compile, compileToFunctions } 1.2 createCompiler 再找 createCompiler 的定义在 src\\compiler\\index.js，引出创建方法 createCompilerCreator 12345678910111213141516171819202122232425262728// src\\compiler\\index.js/** * 模板编译，将模板代码转化为 AST； * 优化 AST，方便后续虚拟 DOM 更新； * 生成代码，将 AST 转化为可执行的代码； */ export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions): CompiledResult { // baseCompile 的调用在： // src\\compiler\\create-compiler.js 中的 const compiled = baseCompile(template.trim(), finalOptions) // 解析 template 模板，转换为 ast const ast = parse(template.trim(), options) if (options.optimize !== false) { // 优化 ast，标记静态节点 optimize(ast, options) } // 将 ast 转化为可执行代码 const code = generate(ast, options) return { ast, render: code.render, staticRenderFns: code.staticRenderFns }}) 1.3 createCompilerCreator 再找createCompilerCreator创建在 src\\compiler\\create-compiler.js，由此引出： createCompileToFunctionFn(compile) compile() 的定义在 createCompiler方法内的子函数 1.3.1 createCompilerCreator 和 compile() 在 compile()的实现中，引出 baseCompile(template.trim(), finalOptions) 1234567891011121314151617181920212223242526// src\\compiler\\create-compiler.jsexport function createCompilerCreator (baseCompile: Function): Function { return function createCompiler (baseOptions: CompilerOptions) { // compile 是在 createCompiler 函数体内定义个一个子函数 // 应用 eg： src\\compiler\\to-function.js 中，const compiled = compile(template, options) function compile ( template: string, options?: CompilerOptions ): CompiledResult { // 深拷贝参数 baseOptions const finalOptions = Object.create(baseOptions) // modules, directives, warn 的合并 ... // baseCompile 方法是 src\\compiler\\index.js 中 创建 const compiled = baseCompile(template.trim(), finalOptions) ... return compiled } return { compile, compileToFunctions: createCompileToFunctionFn(compile) } }} 1.3.1.1 baseCompile(template.trim(), finalOptions)此方法的创建在 1.1.2 内。 调用此方法后，由此引出 ： const ast = parse(template.trim(), options)，具体分析见下文 【 3. 生成AST 】 optimize(ast, options) // todo constcode = generate(ast, options) // todo 1.3.2 createCompileToFunctionFn(compile) 再找 createCompileToFunctionFn(compile) 创建在 src\\compiler\\to-function.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// src\\compiler\\to-function.jstype CompiledFunctionResult = { render: Function; staticRenderFns: Array&lt;Function&gt;;};/** * 创建 编译函数 render, staticRenderFns * @param {创建} compile * @returns CompiledFunctionResult */export function createCompileToFunctionFn (compile: Function): Function { // 创建编译缓存 const cache = Object.create(null) return function compileToFunctions ( template: string, options?: CompilerOptions, vm?: Component ): CompiledFunctionResult { options = extend({}, options) ... // check cache // 检查缓存，有缓存直接用 const key = options.delimiters ? String(options.delimiters) + template : template if (cache[key]) { return cache[key] } // compile // compile 函数 是在 src\\compiler\\create-compiler.js 下，createCompilerCreator 中 return 的 createCompiler 的函数体中定义 const compiled = compile(template, options) // check compilation errors/tips ... // turn code into functions const res = {} const fnGenErrors = [] /** * createFunction 核心 new Function(code) * 将 字符串 创建为 函数 * */ // render 创建好了 res.render = createFunction(compiled.render, fnGenErrors) res.staticRenderFns = compiled.staticRenderFns.map(code =&gt; { return createFunction(code, fnGenErrors) }) // check function generation errors. ... // 创建好的 res 放在缓存 return (cache[key] = res) }} 2. 原始 $mount 方法（**platforms/web/runtime/index**）再调用 原始的 $mount 方法（**src/platforms/web/runtime/index.js**）, 获得元素，返回 mountComponent 方法 123456789101112// src/platforms/web/runtime/index.jsimport { mountComponent } from 'core/instance/lifecycle'// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { // 初始化挂载组件 el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)} mountComponent(this, el, hydrating) 方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// src\\core\\instance\\lifecycle.jsexport function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component { vm.$el = el // 若没有获取解析的 render 函数，抛出警告 // render 是解析模板生成的， // 在 /entry-runtime-with-Compiler.js 中 $mounted() , const { render, staticRenderFns } = compileToFunctions(template,{}) 生成的 if (!vm.$options.render) { ... } callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { // 支持performance的开发环境，添加关于 performance 的分析时间线 updateComponent = () =&gt; { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) // 核心逻辑 同else的，vm._update(vm._render(), hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { // 生产环境环境 // vm._render 用于生成虚拟 DOM // _update 内部调用 patch 方法 将虚拟 DOM 与 真实的 DOM 同步 ( diff ) updateComponent = () =&gt; { vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined // 【new Watcher 初始化】监听当前组件状态，当有数据变化时，更新组件 new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted &amp;&amp; !vm._isDestroyed) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm} 2.1 vm._render()vm._render 用于生成虚拟 dom，执行 dom-diff，更新真实 dom 1234567891011121314151617181920212223242526272829// src\\core\\instance\\render.jsexport function initRender (vm: Component) { // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // 系统创建元素的 方法 // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // 用户提供了 render 属性时创建元素的方法}export function renderMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._render = function (): VNode { const vm: Component = this const { render, _parentVnode } = vm.$options ... // 执行 render 方法中的 createElement 参数就是 vm.$createElement， // vm.$createElement 方法是定义在 initRender 方法上 vnode = render.call(vm._renderProxy, vm.$createElement) ... // createEmptyVNode 的核心 const node = new VNode() vnode = createEmptyVNode() // set parent vnode.parent = _parentVnode return vnode }} 在 initRender, 这里 vm._c 和 vm.$createElement 的区别为： vm._c 是被模板编译成的 render 函数使用； vm.$createElement 是用户手写 render 方法使用的； 两个方法支持的参数相同，并且内部都调用了 createElement 方法 2.1.1 VNode虚拟Dom 的类是 VNode，主要属性是：tag, data, children, text, elm, ns, context, key, parent, raw 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching devtoolsMeta: ?Object; // used to store functional render context for devtools fnScopeId: ?string; // functional scope id support constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) { this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false } // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child (): Component | void { return this.componentInstance }} 2.2 vm._update()把 VNode 渲染成真实的 DOM。 被调用： mountComponent ，在初次渲染时 在 update 时 123456789101112131415161718// src\\core\\instance\\lifecycle.jsexport function lifecycleMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { ... // 初次渲染 // vm.__patch__ 方法：进行 dom diff 比较，然后更新 dom if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates // 更新 vm.$el = vm.__patch__(prevVnode, vnode) } ... }} 2.2.1 Vue.**prototype**.**__patch__**__patch__项目中有两种实现，区分于平台： 1234567// src/platforms/web/runtime/index.js// install platform patch functionVue.prototype.__patch__ = inBrowser ? patch : noop// src/platforms/weex/runtime/index.js// install platform patch functionVue.prototype.__patch__ = patch 2.3 new Watcher关于 Watcher 见 05- Observer 3. 生成 AST如下创建入口，引出 parse方法。 123// src\\compiler\\index.js const ast = parse(template.trim(), options) 例： 如下模板 template： 12345678&lt;div id=&quot;editor&quot;&gt; &lt;!-- 注释 --&gt; &lt;试试\\&lt; &lt;p&gt; &lt;li&gt;li的值&lt;/li&gt; &lt;textarea :value=&quot;input + new Date()&quot; @input=&quot;update&quot;&gt;&lt;/textarea&gt; &lt;div v-html=&quot;compiledMarkdown&quot;&gt;&lt;/div&gt;&lt;/div&gt; 生成的 AST 结构如下： 3.1 parse分析源码，由 parse 引出 parseHTML ， 此处 template ： 注意：在转字符串时： 会 将类似 **&lt;** 直接转为 **&lt;** 会将**&lt;p&gt;** 这样的自动补全为 **&lt;p&gt;&lt;/p&gt;** 12345678910111213141516171819202122232425262728293031323334353637383940// src\\compiler\\parser\\index.js/** * Convert HTML string to AST. * 将 html 字符串 转换为 AST */export function parse ( template: string, options: CompilerOptions): ASTElement | void { ... const stack = [] let root ... parseHTML(template, { warn, expectHTML: options.expectHTML, isUnaryTag: options.isUnaryTag, canBeLeftOpenTag: options.canBeLeftOpenTag, shouldDecodeNewlines: options.shouldDecodeNewlines, shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref, shouldKeepComment: options.comments, outputSourceRange: options.outputSourceRange, start (tag, attrs, unary, start, end) { ... }, end (tag, start, end) { ... }, chars (text: string, start: number, end: number) { ... }, comment (text: string, start, end) { ... } }) return root} 3.1.1 start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960start (tag, attrs, unary, start, end) { // start tag 开头标签回调后执行 // check namespace. // inherit parent ns if there is one const ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag) // handle IE svg bug /* istanbul ignore if */ if (isIE &amp;&amp; ns === 'svg') { attrs = guardIESVGBug(attrs) } // 创建 AST 节点 let element: ASTElement = createASTElement(tag, attrs, currentParent) if (ns) { element.ns = ns } ... // apply pre-transforms for (let i = 0; i &lt; preTransforms.length; i++) { element = preTransforms[i](element, options) || element } if (!inVPre) { processPre(element) if (element.pre) { inVPre = true } } if (platformIsPreTag(element.tag)) { inPre = true } if (inVPre) { processRawAttrs(element) } else if (!element.processed) { // structural directives // 处理指令: v-for v-if v-once processFor(element) processIf(element) processOnce(element) } if (!root) { root = element if (process.env.NODE_ENV !== 'production') { checkRootConstraints(root) } } // 闭合标签将 ast element 存入stack if (!unary) { currentParent = element stack.push(element) } else { // 非闭合标签关闭元素 closeElement(element) } }, 3.1.1.1 createASTElement AST 节点 结构12345678910111213141516// src\\compiler\\parser\\index.jsexport function createASTElement ( tag: string, attrs: Array&lt;ASTAttr&gt;, parent: ASTElement | void): ASTElement { return { type: 1, // 节点类型 tag, // 节点名称 attrsList: attrs, // 属性列表 attrsMap: makeAttrsMap(attrs), // 属性 Map rawAttrsMap: {}, // parent, // 父节点 children: [] // 子节点 }} 【辅助】 makeAttrsMap() 1234567891011121314// 返回转换 attrs 后的map，key 是 attr[i].name, value 是 attrs[i].valuefunction makeAttrsMap (attrs: Array&lt;Object&gt;): Object { const map = {} for (let i = 0, l = attrs.length; i &lt; l; i++) { if ( process.env.NODE_ENV !== 'production' &amp;&amp; map[attrs[i].name] &amp;&amp; !isIE &amp;&amp; !isEdge ) { warn('duplicate attribute: ' + attrs[i].name, attrs[i]) } map[attrs[i].name] = attrs[i].value } return map} 3.1.2 end123456789101112end (tag, start, end) { // end tag 结尾标签回调后执行 const element = stack[stack.length - 1] // pop stack // 出栈，重置当前的父节点 stack.length -= 1 currentParent = stack[stack.length - 1] if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) { element.end = end } closeElement(element) }, 3.1.3 chars123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475chars (text: string, start: number, end: number) { // 文本 回调后执行 // 文本节点外如果没有父节点则不处理报错 if (!currentParent) { if (process.env.NODE_ENV !== 'production') { if (text === template) { warnOnce( 'Component template requires a root element, rather than just text.', { start } ) } else if ((text = text.trim())) { warnOnce( `text &quot;${text}&quot; outside root element will be ignored.`, { start } ) } } return } // IE textarea placeholder bug /* istanbul ignore if */ if (isIE &amp;&amp; currentParent.tag === 'textarea' &amp;&amp; currentParent.attrsMap.placeholder === text ) { return } const children = currentParent.children if (inPre || text.trim()) { text = isTextTag(currentParent) ? text : decodeHTMLCached(text) } else if (!children.length) { // remove the whitespace-only node right after an opening tag text = '' } else if (whitespaceOption) { if (whitespaceOption === 'condense') { // in condense mode, remove the whitespace node if it contains // line break, otherwise condense to a single space text = lineBreakRE.test(text) ? '' : ' ' } else { text = ' ' } } else { text = preserveWhitespace ? ' ' : '' } if (text) { if (!inPre &amp;&amp; whitespaceOption === 'condense') { // condense consecutive whitespaces into single space text = text.replace(whitespaceRE, ' ') } let res let child: ?ASTNode if (!inVPre &amp;&amp; text !== ' ' &amp;&amp; (res = parseText(text, delimiters))) { // 表达式 child = { type: 2, expression: res.expression, tokens: res.tokens, text } } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') { // 静态文本 child = { type: 3, text } } if (child) { if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) { child.start = start child.end = end } children.push(child) } } }, 3.1.4 comment1234567891011121314151617comment (text: string, start, end) { // 注释代码 回调后执行 // adding anything as a sibling to the root node is forbidden // comments should still be allowed, but ignored if (currentParent) { const child: ASTText = { type: 3, text, isComment: true } if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) { child.start = start child.end = end } currentParent.children.push(child) } } 3.2 parseHTML()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155//src\\compiler\\parser\\html-parser.js/** * 根据 options ，对 html字符串 遍历，生成核心参数 match, attrs, * 再通过如 options.start(tagName, attrs, unary, match.start, match.end) 回调 parse 中的start, end, chars, comment 方法 * @param {*} html * @param {*} options */export function parseHTML (html, options) { const stack = [] // 存 非单标签 const expectHTML = options.expectHTML const isUnaryTag = options.isUnaryTag || no const canBeLeftOpenTag = options.canBeLeftOpenTag || no let index = 0 let last, lastTag // 通过 advance 方法递减 html 字符串，直至html为空表示将html全部遍历，结束循环 while (html) { last = html // Make sure we're not in a plaintext content element like script/style if (!lastTag || !isPlainTextElement(lastTag)) { let textEnd = html.indexOf('&lt;') // 以 &lt; 开头 if (textEnd === 0) { // Comment: // 匹配 &lt;!-- 开头 (/^&lt;!\\--/ ) if (comment.test(html)) { const commentEnd = html.indexOf('--&gt;') // 匹配到注释 &lt;!-- --&gt; if (commentEnd &gt;= 0) { if (options.shouldKeepComment) { // options.comment 回调 options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3) } // 截取 注释结束位+3 后 html 片段 ，相当于 参数html 删掉 已匹配的 注释 字符串 advance(commentEnd + 3) continue } } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment // 匹配 条件注释 ![ 开头 /^&lt;!\\[/ if (conditionalComment.test(html)) { const conditionalEnd = html.indexOf(']&gt;') // 匹配到条件注释 &lt;![]&gt; , 如 ![if !IE] if (conditionalEnd &gt;= 0) { advance(conditionalEnd + 2) continue } } // Doctype: // 匹配到 &lt;!DOCTYPE &gt; 删掉 const doctypeMatch = html.match(doctype) if (doctypeMatch) { advance(doctypeMatch[0].length) continue } // End tag: // 匹配 &lt;/ **&gt; 结束标签 const endTagMatch = html.match(endTag) if (endTagMatch) { const curIndex = index advance(endTagMatch[0].length) parseEndTag(endTagMatch[1], curIndex, index) continue } // Start tag: // 匹配 &lt;**&gt; 开始标签 const startTagMatch = parseStartTag() if (startTagMatch) { handleStartTag(startTagMatch) if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) { advance(1) } continue } } let text, rest, next // 参数html 中有 &lt; if (textEnd &gt;= 0) { rest = html.slice(textEnd) // 根据这些判断条件知，这个 if 部分的 &lt; 是文本 &lt; // 循环 &lt; 后的字符串 while ( !endTag.test(rest) &amp;&amp; !startTagOpen.test(rest) &amp;&amp; !comment.test(rest) &amp;&amp; !conditionalComment.test(rest) ) { // &lt; in plain text, be forgiving and treat it as text next = rest.indexOf('&lt;', 1) if (next &lt; 0) break textEnd += next rest = html.slice(textEnd) } // 根据实践，页面中直接写的&lt;,变成字符串html后，会被转换为 &amp;lt; 并不会进上方的 while 循环 // text 获取的是普通文本 text = html.substring(0, textEnd) } // 参数html 中没有 &lt; if (textEnd &lt; 0) { text = html } if (text) { advance(text.length) } // 如果存在 text 文本，则处理 普通文本 的回调 // 调用 options.chars 回调 if (options.chars &amp;&amp; text) { options.chars(text, index - text.length, index) } } else { // 处理结束标签 let endTagLength = 0 const stackedTag = lastTag.toLowerCase() const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(&lt;/' + stackedTag + '[^&gt;]*&gt;)', 'i')) const rest = html.replace(reStackedTag, function (all, text, endTag) { endTagLength = endTag.length if (!isPlainTextElement(stackedTag) &amp;&amp; stackedTag !== 'noscript') { text = text .replace(/&lt;!\\--([\\s\\S]*?)--&gt;/g, '$1') // #7298 .replace(/&lt;!\\[CDATA\\[([\\s\\S]*?)]]&gt;/g, '$1') } if (shouldIgnoreFirstNewline(stackedTag, text)) { text = text.slice(1) } if (options.chars) { options.chars(text) } return '' }) index += html.length - rest.length html = rest parseEndTag(stackedTag, index - endTagLength, index) } if (html === last) { options.chars &amp;&amp; options.chars(html) if (process.env.NODE_ENV !== 'production' &amp;&amp; !stack.length &amp;&amp; options.warn) { options.warn(`Mal-formatted tag at end of template: &quot;${html}&quot;`, { start: index + html.length }) } break } } // Clean up any remaining tags parseEndTag()} 3.2.1 advance1234567891011export function parseHTML (html, options) { /** * 截取 index + n 后的 html （即删除掉 n 前的字符串） * 处理后的标签从html中删除，index 位置相应后移n * @param {} n */ function advance (n) { index += n html = html.substring(n) }} 3.2.2 parseStartTag123456789101112131415161718192021222324252627282930313233export function parseHTML (html, options) { /** * 处理 开始标签 ，将 html 转换为 对象match 格式 * @returns */ function parseStartTag () { const start = html.match(startTagOpen) if (start) { const match = { tagName: start[1], attrs: [], start: index } advance(start[0].length) let end, attr // 把 标签内 属性赋值给match while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) { attr.start = index advance(attr[0].length) attr.end = index match.attrs.push(attr) } // 如果有 结束 的标签 if (end) { match.unarySlash = end[1] // 清掉此句 ，随遍历，随清除 advance(end[0].length) match.end = index return match } } }} 例：遍历到 &lt;textarea :value=&quot;input + newDate()&quot; @input=&quot;update&quot;&gt;，parseStartTag() 得到的 match如下图： 3.2.3 handleStartTag12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export function parseHTML (html, options) { /** * 处理 参数match，得到新格式 attrs， * 未闭合标签入栈， * 回调 start * @param {*} match */ function handleStartTag (match) { const tagName = match.tagName const unarySlash = match.unarySlash if (expectHTML) { if (lastTag === 'p' &amp;&amp; isNonPhrasingTag(tagName)) { parseEndTag(lastTag) }/* export const canBeLeftOpenTag = makeMap( 'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source' ) */ // 针对可以省略 结果标签 的，自动当作已有结尾标签进行处理 if (canBeLeftOpenTag(tagName) &amp;&amp; lastTag === tagName) { parseEndTag(tagName) } } const unary = isUnaryTag(tagName) || !!unarySlash // 遍历处理 attrs 按照新格式 const l = match.attrs.length const attrs = new Array(l) for (let i = 0; i &lt; l; i++) { const args = match.attrs[i] // 这里的 3、4、5 分别对应三种不同复制属性的方式 // 3: attr=&quot;xxx&quot; 双引号 // 4: attr='xxx' 单引号 // 5: attr=xxx 省略引号 const value = args[3] || args[4] || args[5] || '' const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines attrs[i] = { name: args[1], value: decodeAttr(value, shouldDecodeNewlines) } if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) { attrs[i].start = args.start + args[0].match(/^\\s*/).length attrs[i].end = args.end } } if (!unary) { // 非单标签，入栈 stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end }) lastTag = tagName } if (options.start) { // 回调 start options.start(tagName, attrs, unary, match.start, match.end) } }} 例：遍历到 &lt;textarea :value=&quot;input + newDate()&quot; @input=&quot;update&quot;&gt;，handleStartTag() 得到的 attrs如下图： 3.2.4 parseEndTag123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263export function parseHTML (html, options) { /** * 处理结束标签： * 先找未闭合标签的位置pos，回调 end，并在栈中删除已关闭标签 * * @param {*} tagName * @param {*} start * @param {*} end */ function parseEndTag (tagName, start, end) { let pos, lowerCasedTagName if (start == null) start = index if (end == null) end = index // Find the closest opened tag of the same type if (tagName) { lowerCasedTagName = tagName.toLowerCase() // 寻找相同类型的未闭合标签的位置 pos for (pos = stack.length - 1; pos &gt;= 0; pos--) { if (stack[pos].lowerCasedTag === lowerCasedTagName) { break } } } else { // If no tag name is provided, clean shop pos = 0 } if (pos &gt;= 0) { // Close all the open elements, up the stack // 有 pos 位置，如果能和 未闭合stack 栈中匹配（即 stack.length - 1 == pos），则回调 end for (let i = stack.length - 1; i &gt;= pos; i--) { if (process.env.NODE_ENV !== 'production' &amp;&amp; (i &gt; pos || !tagName) &amp;&amp; options.warn ) { options.warn( `tag &lt;${stack[i].tag}&gt; has no matching end tag.`, { start: stack[i].start, end: stack[i].end } ) } if (options.end) { options.end(stack[i].tag, start, end) } } // Remove the open elements from the stack // 并在栈中删除已关闭标签 stack.length = pos lastTag = pos &amp;&amp; stack[pos - 1].tag } else if (lowerCasedTagName === 'br') { if (options.start) { options.start(tagName, [], true, start, end) } } else if (lowerCasedTagName === 'p') { if (options.start) { options.start(tagName, [], false, start, end) } if (options.end) { options.end(tagName, start, end) } } }} 4. optimize()同 3 中模板， 如下创建入口，引出 optimize方法。 123// src\\compiler\\index.js optimize(ast, options) 得到 ast 结构如下图： 对比上一步的ast，多了一个 static，staticRoot。 具体原因，之后再继续琢磨。 5. generate()同 3 中模板， 如下创建入口，引出 generate方法。 123456789// src\\compiler\\index.jsconst code = generate(ast, options) return { ast, render: code.render, staticRenderFns: code.staticRenderFns } 得到 code 如下图： render 创建了！render 的结构： 123456789101112131415161718192021222324252627`with(this){ return_c('div', { attrs: { &quot;id&quot;: &quot;editor&quot; } }, [ _v(&quot;\\\\n &lt;试试\\\\\\\\&lt;\\\\n &quot;), _c('textarea', { domProps: { &quot;value&quot;: input+newDate() }, on: { &quot;input&quot;: update } }), _v(&quot; &quot;), _c('div', { domProps: { &quot;innerHTML&quot;: _s(compiledMarkdown) } }) ])}` 这里的 _c 对应的是虚拟 DOM 中的 createElement 方法。 其他的下划线方法在 core/instance/render-helpers 中都有定义。 参考： https://juejin.cn/post/7064788398304657415 https://juejin.cn/post/6863241580753616903 着重记下这位大佬推荐的 正则可视化工具 (๑•̀ㅂ•́)و✧","link":"/106-%E6%A8%A1%E7%89%88%E6%B8%B2%E6%9F%93/"},{"title":"原型与继承","text":"1. 原型 原型 是 函数的 **prototype**属性。 每个函数都有一个特殊属性prototype的对象，即原型对象。此函数的实例，共享函数的属性及方法（即原型模式）。 函数的 原型对象（prototype） 中，有一个内部属性 constructor，这个属性指向该函数。 一个名为 Fun 的空函数的 prototype 如下： 2.原型链2.1 __proto__ 从函数的prototype属性派生的。 同 [[prototype]] __proto__相当于一个指针，在对象实例和它的构造器之间建立一个链接，用来指向创建它的构造函数的原型对象的（实例的__proto__指向构造器的 prototype）。 2.1.1 实例的 __proto__123function Fun() {}var f1 = new Fun() **Fun.__proto__** 指向内置匿名函数 anonymous，因为 Fun 是个函数对象，默认由 Function 作为类创建 1234// 实例的__proto__指向构造器的 prototypef1.__proto__ === Fun.prototype // trueFun.prototype.constructor === Fun // true Fun.prototype.__proto__ 指向Object.prototype，因为 Fun.prototype 是个对象，默认基于 Object函数作为构造函数创建的，故指向 Object.prototype 1Fun.prototype.__proto__ === Object.prototype // true 构造函数是一个函数对象，而函数对象都是 Function 构造产生，所以 构造函数的 __proto__指向 Function 的原型 Object 对象直接继承自 Function 对象 123Fun.__proto__ === Function.prototype // trueObject.__proto__ === Function.prototype // true 一切对象都是继承自 Object对象，Object 对象直接继承根源对象 null 1Object.prototype.__proto__ === null // true 2.1.2 类的 __proto__12345678class A {}class B extends A {}B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 子类的 __proto__属性，表示构造函数的继承，总是指向父类 子类 prototype 属性的__proto__属性，表示方法的继承，总是指向父类的原型 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性 ( https://es6.ruanyifeng.com/?search=extends&x=0&y=0#docs/class-extends#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C__proto__%E5%B1%9E%E6%80%A7 ) 2.2 构造函数、原型、实例的关系 每个构造函数都有一个原型对象（prototype） 原型对象的属性constructor指向构造函数本身 构造函数的实例包含一个指向原型对象的内部指针（__proto__） 3. 继承js面向过程语言，本身不存在继承。继承（inheritance）是面向对象的一个概念。 123456789101112function Parent() { this.v1 = 1 this.v2 = 2 this.obj = { name: 'parent'} this.getV2 = function() { console.log('getB') }}Parent.prototype.v3 = 'v333'Parent.prototype.getV1 = function() { console.log('getA')} 3.1 原型链核心： 使用原型，让一个引用类型继承另一个引用类型的属性和方法。 将子类原型对象指向父类的实例，子类的实例则可以继承父类的属性（即子类的实例的**__proto__**指向父类）。 12345678910111213141516171819function Child1() { this.aa = 11}Child1.prototype = new Parent()var a1 = new Child1()var a2 = new Child1()console.log(a1) // Child1 {aa: 11}// 可继承 父类和原型对象上 的方法console.log(a1.getV1(), a1.getV2()) // getA getB// 修改普通类型的值，其他子类的实例不会被影响a2.v3 = 123console.log(a1.v3,a2.v3) // v333 123// 修改引用类型的值时，所有子类实例都会被修改a1.obj.name = 'name'console.log(a1.obj,a2.obj) // {name: 'name'} {name: 'name'} 优点： 子类可以继承父类普通类型的属性，及定义在原型上的方法。 缺点： 无法实现多继承。（一个实例无法指向两个原型） 所有的属性都是共享的（先在实例找，再在原型对象上找），修改引用类型的值时，所有子类实例都会被修改 无法传递参数。 3.2 借用构造函数核心： 在子类的构造函数中，apply() 调用父类构造函数（把父类的函数重新运行一遍） 12345678910111213function Child2() { Parent.apply(this, arguments)}var b1 = new Child2()var b2 = new Child2()// 修改引用类型的值时，子类实例不会相互影响b1.obj.name = 'haha'console.log(b1.obj,b2.obj) // {name: 'haha'} {name: 'parent'}// 不能继承 父类原型对象上 的属性和方法console.log(b1.v3) // undefinedconsole.log(b1.getV2(), b1.getV1()) // getB TypeError: b1.getV1 is not a function 优点： 可以多继承，可调用几次 apply 解决内部属性会共享的问题（每创建一个子类的实例，都会把父类再重新运行一遍，因此每个子类的实例指向不同的地址） 可以传参，子类的参数会在父类中运行一遍 缺点： new 创建的实例只是子类的实例，不是父类的实例，只是相当于把父类拷下来再运行一遍。 只能继承父类构造函数中的属性和方法，不能继承父类原型中的属性和方法；（一般会在构造函数中写一些属性，在原型中写一些方法） 3.3 组合继承（伪经典）原理：在借用构造函数方式的基础上，使用原型链实现原型属性和方法的继承。 123456789function Child3() { Parent.apply(this, arguments)}Child3.prototype = new Parent()Child3.prototype.constructor = Child3var c1 = new Child3()console.log(c1.v3, c1.getV1()) // getA v333 优点： 多继承 可以传参 原型的指向也都是正确的 缺点： 构造函数被运行了两次。 父类的构造函数被调用两次，第一次在创建子类原型 Child.prototype = new Parent() 时，第二次在call/apply 时，若父类构造函数大或者耗性能，整体性能会受影响。 构造函数中的属性和方法，同时存在于实例和原型中。 当用 new Parent() 创建实例时，构造函数的属性或方法在子类实例上有一份，在子类的原型上也会有一份，但由于同名覆盖，不会出错。但属性和实例会实例和实例的原型中个存在一份，占用多余内存。 3.4 原型式继承原理： 通过 Object.create() 实现字符字面量对象的继承。 12345678910111213141516var Parent2 = { v1: 1, v2: 2, obj: { name: 'parent'}, getV2: function() { console.log('getB') }}var d1 = Object.create(Parent2)var d2 = Object.create(Parent2)d1.v1 = 123d1.obj.name = 'hhh'console.log(d2.v1, d2.obj.name) // 1 'hhh' 原型链继承，是继承一个构造函数。 原型继承，是继承一个普通对象。 缺点： Object.create方法是浅拷贝，多个实例的引用类型属性指向相同的内存，会相互影响 3.5 寄生式继承原理： 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再想真得是它做了所有工作一样的返回对象。 （将原型继承封装起来，同时增加属性和方法。） 12345678function createPlus(){ var clone = Object.create(Parent2); clone.getOrg = function(){ alert('hi plus'); } return clone;}var a1 = createPlus(a); 缺点： 同原型继承 3.6 寄生组合式继承(完美继承)原理： 寄生组合式继承，就是借用构造函数来继承属性，通过原型链的混成形式来继承方法。 在组合继承的基础上，将 new Parent() 方式修改为 Object.create()，以解决构造函数执行两遍的问题。 1234567891011121314151617function Child6 () { Parent.apply(this,arguments)}function clone (parent, child) { child.prototype = Object.create(parent.prototype) child.prototype.constructor = child}clone(Parent, Child6)var f1 = new Child6()var f2 = new Child6()f1.v1 = 123f1.obj.name = 'hhh'console.log(f2.v1, f2.obj.name) // 1 'parent'console.log(f1.getV2(), f1.getV1()) // getB getA ES6 中的 extends 关键字直接实现 JavaScript的寄生组合继承。","link":"/04-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"title":"闭包","text":"1. 闭包闭包让你可以在一个内层函数中访问到其外层函数的作用域。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数“。 结构：在函数内部返回一个函数。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 1234567891011121314151617181920function eg3(){ var n = 9; var f2 = function(){ alert(n); }; return f2;};eg3()();//或function eg3(){ var n = 9; var f2 = function(){ alert(n); }; return f2();};eg3(); 闭包原理： Javascript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 2. 使用场景闭包的主要用途： 读取函数内部的变量 让这些变量的值始终保持在内存中 2.1 使用闭包模拟私有方法及变量（封装）123456789101112function Person(){ var name = &quot;default&quot;; return { getName : function(){ return name; }, setName : function(newName){ name = newName; } } }; 2.2 函数防抖12345678function debounce(fn, delay) { var timer return function(...args) { clearTimeout(timer) setTimeout(()=&gt;{ fn.apply(this, args) }, delay) } 2.3 缓存变量 or 方法f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。nAdd相当于是一个setter。 1234567891011121314151617181920212223function Person(){ var name = &quot;default&quot;; return { getName : function(){ return name; }, setName : function(newName){ name = newName; } } }; var john = Person(); print(john.getName()); john.setName(&quot;john&quot;); print(john.getName()); var jack = Person(); print(jack.getName()); jack.setName(&quot;jack&quot;); print(jack.getName()); 2.4 柯里化函数为了提升性能，使用柯里化可以缓存一部分能力。 123456789101112131415161718192021/** * Make a map and return a function for checking if a key * is in that map. *///创建一个map，返回一个检查key是否在map中的函数export function makeMap ( str: string, expectsLowerCase?: boolean): (key: string) =&gt; true | void { const map = Object.create(null) const list: Array&lt;string&gt; = str.split(',') for (let i = 0; i &lt; list.length; i++) { map[list[i]] = true } return expectsLowerCase ? val =&gt; map[val.toLowerCase()] : val =&gt; map[val]}// 判断是否是文本输入类型var isTextInputType = makeMap('text,number,password,search,email,tel,url');isTextInputType(typeA) 2.5 高阶函数高阶函数，简单的说一般都是一个函数，参数是函数，返回值也是函数。一般都用到了闭包作为公共变量或缓存。 12345678910111213141516/** * Create a cached version of a pure function. */export function cached&lt;F: Function&gt; (fn: F): F { const cache = Object.create(null) return (function cachedFn (str: string) { const hit = cache[str] return hit || (cache[str] = fn(str)) }: any)}// 执行 cached 后返回的 idToTemplate 每次执行参数都会被 cached 的参数执行，并且缓存在 hit const idToTemplate = cached(id =&gt; { const el = query(id) return el &amp;&amp; el.innerHTML}) 3. 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 避免闭包中存在增长闭包的情况，闭包内缓存的值不断循环增加，导致内存泄露。 参考资料：http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html","link":"/05-%E9%97%AD%E5%8C%85/"},{"title":"前端无感知刷新token","text":"需求背景： 后端的 token 机制，每次发送请求，都会自动延长 token 的过期时间 需求场景： 网站有很多数据待核对， 用户并未刷新或操作网站，一段时间后，当用户终于核对输入好数据后，点保存按钮，登录过期￣□￣｜｜。 解决思路：监听用户的鼠标移动事件，若移动则触发一个轻量后端请求，以延长 token 过期时间，以此达到无感知刷新 token 的效果。 代码：在主页面中，监听全局页面的鼠标移动事件，通过节流，在一段时间内调用刷新请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 主页面 main.vue&lt;template&gt; &lt;div @mousemove=&quot;mouseMove&quot; &gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const refreshTokenTime = 1000 * 60 * 5 // 暂定5分钟 export default { data () { return { handleMove: '' } }, mounted () { this.handleMove = this.throttled(this.mouseMoveFn, refreshTokenTime) }, methods: { mouseMove () { this.handleMove() }, // 激活 mouseMoveFn () { console.log('move') // 刷新 token 的请求 this.$http({ isRefresh: true, url: '/**/info', method: 'get' }).then(() =&gt; { // 如果有需要，可以刷新后，修改本地存储、token等信息 }) }, // 除了恶意修改本地时间，用时间戳方式节流 throttled (fn, delay) { let last = 0 return (...args) =&gt; { let now = new Date() if (now - last &gt;= delay) { fn.apply(this, args) last = now } } } } }&lt;/script&gt; 寻找更加优雅的方案，欢迎指点~附：JWT 方式实现思路详细可看： https://juejin.cn/post/7023253083475935240#heading-9https://www.zhihu.com/question/316165120/answer/1490826572 通过长短token实现：短token用来请求应用数据，长token用于获取新的短token（长短指的是过期时间） 短token过期了，用长token调后端接口获取新的短token。如果长token也过期了，直接跳转到登录页重新登录。 Access Token即“访问令牌”，是客户端向资源服务器换取资源的凭证； Refresh Token即“刷新令牌”，是客户端向认证服务器换取Access Token的凭证。 用户提供身份信息（一般是用户名密码），利用客户端向认证服务器换取 Refresh Token和Access Token； 客户端携带Access Token访问资源服务器，资源服务器识别Access Token并返回资源； 当Access Token过期或失效，客户端再一次访问资源服务器，资源服务器返回“无效token”报错； 客户端通过Refresh Token向认证服务器换取Access Token，认证服务器返回新的Access Token。","link":"/303-%E5%89%8D%E7%AB%AF%E6%97%A0%E6%84%9F%E7%9F%A5%E5%88%B7%E6%96%B0token/"},{"title":"静态方法vs实例方法vs原型方法","text":"例子对比：1234567891011121314151617181920212223242526272829303132// 构造函数const Person = function(name){ console.log('初始化构造函数') this.name = name // 构造函数内的方法 this.getName = function(){ console.log('调用构造函数内的方法') // return name }}// 静态方法Person.staticFunc = function(){ console.log('调用静态方法')}// 原型方法Person.prototype.protoFunc = function(){ console.log('调用原型方法')}// 实例对象let p1 = new Person('Luna') // 输出： 初始化构造函数p1.getName() // 输出： 调用构造函数内的方法p1.protoFunc() // 输出： 调用原型方法p1.staticFunc // 输出： undefinedPerson.getName // 输出： undefined Person.protoFunc // 输出： undefinedPerson.staticFunc() // 输出： 调用静态方法 静态方法static 关键字定义了静态方法或字段，或静态初始化块（有关这种用法的更多信息，请参阅链接）。静态属性不能在类的实例上直接访问。相反，它们是在类本身上被访问的。 静态方法通常是实用函数，如创建或克隆对象的函数，而静态属性则适用于缓存、固定配置或其他不需要跨实例复制的数据。 当你希望一个字段在每个类中只存在一次，而不是在你创建的每个类实例中都存在时，公有静态字段就很有用。这对缓存、固定配置或其他不需要在实例间复制的数据非常有用。 构造函数：构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象实例的时候，必须使用new命令。 实例方法：实例对象调用的构造函数内的方法。 原型方法：希望在已存在的对象、构造函数添加新的属性或方法，就在对象或构造函数的 prototype 属性上增加新属性和方法。 实例之间共享prototype上的属性和方法。 共享而非复制通过将方法和属性定义在prototype上，所有的实例都会共享这些属性和方法，而不是在每个实例创建时复制一份。这意味着无论创建多少个实例，它们都使用同一个方法的引用，这有助于减少脚本的内存使用量。 减少内存使用，优化性能当实例需要访问构造函数原型上的属性或方法时，它们会通过原型链来进行查找。这种查找机制相比于在每个对象实例中存储自己的副本要高效得多，因为它避免了不必要的内存浪费，从而提高程序运行的性能。 总结： 实例对象可以调用的方法：构造函数内的方法、原型方法； 构造函数可以调用的方法：静态方法； https://docs.pingcode.com/ask/168242.html https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_objects","link":"/06-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95vs%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95vs%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/"},{"title":"块级作用域","text":"块级作用域定义：块作用域是指被大括号（“{}”）包裹住的相关联的语句的集合。例如，你可以在 if (condition) 后声明一段块作用域形式的代码，表明当条件判断为真时，解释程序应该运行上述块作用域里的代码，或者当条件判断为假时跳过执行上述块作用域里的代码。 举例：var 没有块级作用域，但let``const 有。 12345678var c3 = 123;console.log(c3)if (true) { var c3 = 'abc'; console.log(c3)}console.log(c3)// 输出：123 abc abc 12345678let c1 = 123;console.log(c1)if (true) { let c1 = 'abc'; console.log(c1)}console.log(c1)// 输出：123 abc 123 块级作用域可规避的问题： 内层变量不会覆盖外层变量 避免计数的循环变量泄露为全局变量，如： 123456789101112131415161718192021for (var i = 0; i &lt; 2; i++){ console.log('in=&gt;'+i);}console.log('out=&gt;'+i);// 输出：in=&gt;0 in=&gt;1 out=&gt;2let i = 1// Uncaught SyntaxError: Identifier 'i' has already been declared// 但包在for 中，let i 声明，并不会报错，如下：for (let i = 0; i &lt; 2; i++){}// 用let声明计数变量jfor (let j = 0; j &lt; 2; j++){ console.log('in=&gt;'+j);}console.log('out=&gt;'+j);// 输出：// in=&gt;0// in=&gt;1 // VM367:4 Uncaught ReferenceError: j is not defined at &lt;anonymous&gt;:4:21 在 for 循环中定义的变量 i，通常是想在 for 循环内部的上下文中使用 i，但用 var声明会将 i 会绑定在外部作用域(函数或全局)中。","link":"/07-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"用proxyman调试设备(Mac)","text":"安装 Proxyman Tools -&gt; proxy settings -&gt; override macOs proxy 关闭，即停止了本机的抓包 certificate -&gt; install certificate on ios -&gt; physical Devices 安装证书 遇到的问题： 第3步，打不开这个网址 解决： 重新连 wifi。 https://docs.proxyman.io/troubleshooting/ios-16-devices-issues#1.-problem 打开 proxy.man/ssl 后，弹框点击 allow ，后进入 到 setting ，左侧列表中，会有 安装证书的一行。 连接后，仍然打不开内网网址 https://*** 解决： 清 Safari 的缓存，重新进入，安全链接选仍打开。","link":"/304-%E7%94%A8proxyman%E8%B0%83%E8%AF%95%E8%AE%BE%E5%A4%87(Mac)/"},{"title":"window.performance","text":"2. window.performance 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// memory 是非标准属性，只在 Chrome 有memory: { usedJSHeapSize: 16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize totalJSHeapSize: 35100000, // 可使用的内存 jsHeapSizeLimit: 793000000 // 内存大小限制}, // 哲学问题：我从哪里来？navigation: { redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来 type: 0 // 0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等） // 1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面 // 2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录） // 255 即 TYPE_UNDEFINED 非以上方式进入的页面}, timing: { // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等 navigationStart: 1441112691935, // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0 unloadEventStart: 0, // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳 unloadEventEnd: 0, // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 redirectStart: 0, // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 redirectEnd: 0, // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前 fetchStart: 1441112692155, // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 domainLookupStart: 1441112692155, // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 domainLookupEnd: 1441112692155, // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等 // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间 connectStart: 1441112692155, // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等 // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间 // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过 connectEnd: 1441112692155, // HTTPS 连接开始的时间，如果不是安全连接，则值为 0 secureConnectionStart: 0, // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存 // 连接错误重连时，这里显示的也是新建立连接的时间 requestStart: 1441112692158, // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存 responseStart: 1441112692686, // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存 responseEnd: 1441112692687, // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件 domLoading: 1441112692690, // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件 // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源 domInteractive: 1441112693093, // DOM 解析完成后，网页内资源加载开始的时间 // 在 DOMContentLoaded 事件抛出前发生 domContentLoadedEventStart: 1441112693093, // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕） domContentLoadedEventEnd: 1441112693101, // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件 domComplete: 1441112693214, // load 事件发送给文档，也即 load 回调函数开始执行的时间 // 注意如果没有绑定 load 事件，值为 0 loadEventStart: 1441112693214, // load 事件的回调函数执行完毕的时间 loadEventEnd: 1441112693215} 使用 performance.timing 信息简单计算出网页性能数据:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 计算加载时间function getPerformanceTiming () { var performance = window.performance; if (!performance) { // 当前浏览器不支持 console.log('你的浏览器不支持 performance 接口'); return; } var t = performance.timing; var times = {}; //【重要】页面加载完成的时间 //【原因】这几乎代表了用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart; //【重要】解析 DOM 树结构的时间 //【原因】反省下你的 DOM 树嵌套是不是太多了！ times.domReady = t.domComplete - t.responseEnd; //【重要】重定向的时间 //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com times.redirect = t.redirectEnd - t.redirectStart; //【重要】DNS 查询时间 //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？ // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364) times.lookupDomain = t.domainLookupEnd - t.domainLookupStart; //【重要】读取页面第一个字节的时间 //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？ // TTFB 即 Time To First Byte 的意思 // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte times.ttfb = t.responseStart - t.navigationStart; //【重要】内容加载完成的时间 //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？ times.request = t.responseEnd - t.requestStart; //【重要】执行 onload 回调函数的时间 //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？ times.loadEvent = t.loadEventEnd - t.loadEventStart; // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart; // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart; // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart; return times;} 使用 performance.mark() 标记各种时间戳使用 performance.measure() 计算mark标记的时间 duration123456789101112131415161718192021222324252627function randomFunc (n) { if (!n) { // 生成一个随机数 n = ~~(Math.random() * 10000); } var nameStart = 'markStart' + n; var nameEnd = 'markEnd' + n; // 函数执行前做个标记 window.performance.mark(nameStart); for (var i = 0; i &lt; n; i++) { // do nothing } // 函数执行后再做个标记 window.performance.mark(nameEnd); // mark 用法！ // 然后测量这个两个标记间的时间距离，并保存起来 var name = 'measureRandomFunc' + n; window.performance.measure(name, nameStart, nameEnd); // measur 用法！} // 执行三次看看randomFunc(); randomFunc(); // 指定一个名字randomFunc(888); 使用performance.getEntries() 获取所有资源请求的时间数据1234// 看下保存起来的标记 markvar marks = window.performance.getEntriesByType('mark'); // 看下保存起来的测量 measurevar measure = window.performance.getEntriesByType('measure'); 清除标记：123456789// 清除指定标记window.performance.clearMarks('markStart888'); // 清除所有标记window.performance.clearMarks(); // 清除指定测量window.performance.clearMeasures('measureRandomFunc'); // 清除所有测量window.performance.clearMeasures(); 属性performance.timing ：包含延迟相关的性能信息。 performance.navigation ：表示在当前给定浏览上下文中网页导航的类型以及次数。 performance.memory ：在Chrome中添加的一个非标准扩展。 方法performance.mark()： 通过一个给定的名称，将该名称（作为键）和对应的DOMHighResTimeStamp（作为值）保存在一个哈希结构里。该键值对表示了从某一时刻（译者注：某一时刻通常是 navigationStart 事件发生时刻）到记录时刻间隔的毫秒数。（译者注：该方法一般用来多次记录时间，用于求得各记录间的时间差） performance.now()： 该方法返回一个DOMHighResTimeStamp对象，该对象表示从某一时刻（译者注：某一时刻通常是 navigationStart 事件发生时刻）到调用该方法时刻的毫秒数。 参考： https://www.cnblogs.com/zhuyang/p/4789020.html","link":"/305-window.performance/"},{"title":"async函数","text":"1. 是什么？async function 声明创建一个绑定到给定名称的新异步函数。函数体内允许使用 await 关键字，这使得我们可以更简洁地编写基于 promise 的异步代码，并且避免了显式地配置 promise 链的需要。 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 12345// async 写法const asyncReadFile = async function () { const f1 = await readFile('/etc/abc'); const f2 = await readFile('/etc/def');}; 1.1. 和 Generator 函数 对比 async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await Generator 函数的执行必须靠执行器，而async函数自带执行器。即 async函数的执行，与普通函数一样。 12345// Generator 写法const gen = function* () { const f1 = yield readFile('/etc/abc'); const f2 = yield readFile('/etc/def');}; 1.2. 和 Promise 调用 对比12345678910// Promise 写法const promiseReadFile = function () { let p1 = new Promise((resolve)=&gt;{ readFile('/etc/abc'); resolve(true) }).then(v=&gt;console.log(v)) let p2 = new Promise((resolve)=&gt;{ readFile('/etc/def'); })}; 2. 基本用法2.1. async async声明的函数返回的是**Promise**对象，可用**then**方法添加回调函数。 只有async函数内部的异步操作执行完，才会执行**then**方法指定的回调函数。 **async**函数内部return语句返回的值，会成为**then**方法回调函数的参数，若没有return的值，则参数为undefined。 2.2. await await必须在async声明的函数内使用。 **await**命令后面必须是 **Promise** 对象，然后返回该对象的结果。 await后面是 Promise 对象本身； await后面是原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 **Promise** 对象）。然后直接返回对应的值。 await后面是一个thenable对象（即定义了**then**方法的对象），await会将其视为**Promise**处理。 当函数执行的时候，一旦遇到await就会先不往下执行，等 await 后的异步操作完成，再接着执行函数体内后面的语句。 1234567891011121314151617181920212223242526272829303132333435function timeout(ms) { console.log('timeout...', ms) return new Promise((resolve) =&gt; { console.log('timeout promise...', resolve) setTimeout(()=&gt;resolve('t resolve'), ms); });}async function asyncPrint(value, ms) { console.log(1) // await命令后面的 Promise 对象，接收其resolve/reject 的参数 let p = await timeout(ms); console.log(2, p, value, ms); return value}// async 函数返回一个Promise对象, eg:asylet asy = asyncPrint('hello world', 50)console.log('asy...', asy)// then 接收回调结果，参数是 async 内 return 的返回值, eg:v// 只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。asy.then(v =&gt; console.log('then...',v));console.log(3)// 输出：// 1// timeout... 50// timeout promise... ƒ () { [native code] }// asy... Promise{}// 3// 2 't return' 'hello world' 50// then... hello world 2.3. 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise对象被reject。 为了防止出错，将**await**操作放在**try...catch**代码块之中。 123456789101112async function main() { try { const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); } catch (err) { console.error(err); }} 3. 易错点3.1. await命令后面必须放Promise对象 或 原始数据类型值、thenable对象。3.2. await命令后的Promise对象声明时需要有有完整的从 pending 变为 resolved/reject 的部分，否则 Promise 会一直处于 pending 状态。12345678910111213141516171819202122232425262728293031function timeoutPending() { return new Promise(()=&gt;{ setTimeout(()=&gt;{ console.log('timeout-Pending') },1) })}function timeout() { return new Promise((resolve)=&gt;{ setTimeout(()=&gt;{ console.log('timeout-Success') resolve('success') }, 10) })}async function getFoo() { // 返回 fulfilled 状态 let foo2 = await timeout() console.log('2', foo2); // 返回 pending 状态，不会往下执行 let foo1 = await timeoutPending() console.log('1', foo1); console.log(3);}// 输出：// timeout-Success// 2 success// timeout-Pending 3.3. 多个请求串行与并行3.3.1. 如下是串行与并行，两种写法的例子 写法1： 1234567891011121314151617181920212223242526function getFoo() { return new Promise((res)=&gt;{ setTimeout(()=&gt;res('getFoo'),2000) })}function getBar() { return new Promise((res)=&gt;{ setTimeout(()=&gt;res('getBar'),1000) })}// 串行async function getAll() { console.log('1', new Date().getSeconds()); let foo = await getFoo(); console.log('2', new Date().getSeconds(), foo); let bar = await getBar(); console.log('3', new Date().getSeconds(), bar);}getAll()// 输出：// 1 29// Promise {&lt;fulfilled&gt;}// 2 31 getFoo// 3 32 getBar 12345678910111213141516171819202122232425262728function getFoo() { return new Promise((res)=&gt;{ setTimeout(()=&gt;res('getFoo'),2000) })}function getBar() { return new Promise((res)=&gt;{ setTimeout(()=&gt;res('getBar'),1000) })}// 并行async function getAll() { console.log('1', new Date().getSeconds()); let f = getFoo(); let b = getBar() let foo = await f; console.log('2', new Date().getSeconds(), foo); let bar = await b; console.log('3', new Date().getSeconds(), bar);}getAll()// 输出：// 1 32// Promise {&lt;fulfilled&gt;}// 2 34 getFoo// 3 34 getBar 写法2： 123456789101112131415161718192021222324252627282930313233343536373839404142// 串行async function getAll() { let getFoo = new Promise((res)=&gt;{ setTimeout(()=&gt;res('getFoo'),2000) }) console.log('1', new Date().getSeconds()); let foo = await getFoo; console.log('2', new Date().getSeconds(), foo); let getBar = new Promise((res)=&gt;{ setTimeout(()=&gt;res('getBar'),1000) }) let bar = await getBar; console.log('3', new Date().getSeconds(), bar);}getAll()// 输出：// 1 45// Promise {&lt;fulfilled&gt;}// 2 47 getFoo// 3 48 getBar// 并行async function getAll() { console.log('1', new Date().getSeconds()); let getFoo = new Promise((res)=&gt;{ setTimeout(()=&gt;res('getFoo'),2000) }) let getBar = new Promise((res)=&gt;{ setTimeout(()=&gt;res('getBar'),1000) }) let foo = await getFoo; console.log('2', new Date().getSeconds(), foo); let bar = await getBar; console.log('3', new Date().getSeconds(), bar);}getAll()// 输出：// 1 36// Promise {&lt;fulfilled&gt;}// 2 38 getFoo// 3 38 getBar 3.3.2. 分析 现象 多个请求串行，是后一个等前一个执行成功后再去请求；多个请求并行，是所有请求一起去执行。 如上左侧是串行的例子，串行代码总执行时间需要3s，并行代码只需2s。 原因分析 如上例子串行与并行请求代码的区别，通过调整代码顺序即可实现。可为什么呢？ 其原因是 **Promise**的运行机制，****Promise 新建（即： **new Promise()**）后就会立即执行。 如写法2： 串行代码，在创建 getFoo 变量时，就开始执行了new Promise()内的代码了，遇到await后，等待pending状态改变为fulfilled/reject 后，继续执行下面的语句，过程同前面； 而并行代码，一开始先创建getFoo、getBar 变量，就意味着将两个new Promise()内的代码的代码都执行了，再遇到await，等到pending状态改变为fulfilled/reject 后，继续执行下一个await。 如果第一个需要2s，第二个需要1s，则第一个await结果返回后，第二个结果也已经返回，则如例子所示，两个的时间是一样的； 如果如果第一个需要1s，第二个需要2s，则第一个await结果返回后，被第二个await拦住等待状态改变，改变后再继续往下执行。 附：串、并行的 Promise 写法： 12345678910111213141516171819202122// 并行async function getAll() { console.log('1', new Date().getSeconds()); let getFoo = new Promise((res)=&gt;{ setTimeout(()=&gt;{res('getFoo');console.log('2', new Date().getSeconds(), getFoo);},2000) }) let getBar = new Promise((res)=&gt;{ setTimeout(()=&gt;{res('getBar');console.log('3', new Date().getSeconds(), getBar)},1000) })}// 串行async function getAll() { console.log('1', new Date().getSeconds()); let getFoo = new Promise((res)=&gt;{ setTimeout(()=&gt;{res('getFoo');console.log('2', new Date().getSeconds(), getFoo);},2000) }).then((v)=&gt;{ let getBar = new Promise((res)=&gt;{ setTimeout(()=&gt;{res('getBar');console.log('3', new Date().getSeconds(), getBar)},1000) }) })}","link":"/402-async%E5%87%BD%E6%95%B0/"},{"title":"堆","text":"实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * @param {number[]} nums * @param {number} k * @return {number} */ class MinHeap { // 用数组存储堆元素 constructor() { this.heap = []; } // 获取下标为i的父节点下标 getParentIndex(i) { return (i - 1) &gt;&gt; 1; } // 获得下标为i的左节点下标 getleftIndex(i) { return 2 * i + 1; } // 获得下标为i的右节点下标 getrightIndex(i) { return 2 * i + 2; } // 交换节点位置 swap(i1, i2) { [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]]; } // 上移（上浮）- 【递归写法】 shiftUp2(index) { if (index === 0) return; const parentIndex = this.getParentIndex(index); if (this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex, index); this.shiftUp(parentIndex); } } // 下移（下沉）- 【递归写法】 shiftDown2(index) { const leftIndex = this.getleftIndex(index); const rightIndex = this.getrightIndex(index); let max = index if (this.heap[leftIndex] &lt; this.heap[index]) { this.swap(leftIndex, index); this.shiftDown(leftIndex); } if (this.heap[rightIndex] &lt; this.heap[index]) { this.swap(rightIndex, index); this.shiftDown(rightIndex); } } // 插入 insert(value) { // 堆尾插入新值 this.heap.push(value); // 堆自底而上，重新排序 this.shiftUp(this.heap.length - 1); } // 删除堆顶 shift() { // 将最后一个叶子节点（即数组最后一个元素）移到堆顶（即：删除堆顶） // pop()方法删除数组最后一个元素并返回该元素的值，将此值赋值给堆顶 this.heap[0] = this.heap.pop(); // 堆自顶而下，重新排序 this.shiftDown(0); } // 获取堆顶 peek() { return this.heap[0]; } // 获取堆长度 size() { return this.heap.length; } // 打印堆内容 print(name = '') { console.log(name, this.heap); }}var findKthLargest = function(nums, k) { // 一、建堆 const heap = new MinHeap(); for (const num of nums) { // 二、调整堆内顺序 // 将数组元素依次插入堆中 heap.insert(num); // 三、删除 // 如果堆大小超过k， 开始裁员， 将堆顶(最小) 的去掉 if (heap.size() &gt; k) heap.shift(); } // 返回堆顶，即第k大元素 return heap.peek();}; 循环嵌套递归，易导致内存溢出。 易错点记录：1234567891011121314151617181920212223242526272829303132333435363738394041// 错误写法shiftDown(index) { const leftIndex = this.getleftIndex(index); const rightIndex = this.getrightIndex(index); // 这种写法，在满足一个if后，再看是否满足第二个if， // 若两个都满足，则第二个会把第一个本应递归的下标覆盖掉，就会出现两者只递归一次的情况 let i = index console.log(this.heap, index, i) if (this.heap[leftIndex] &lt; this.heap[index]) { console.log('left', leftIndex, index) i = leftIndex } if (this.heap[rightIndex] &lt; this.heap[index]) { console.log('right', rightIndex, index) i = rightIndex } console.log('i', i, index) if (i != index) { this.swap(i, index); this.shiftDown(i); } }// 正确写法// 下移（下沉） shiftDown(index) { const leftIndex = this.getleftIndex(index); const rightIndex = this.getrightIndex(index); console.log(this.heap, index) // 这种写法，在满足一个if后就会递归，满足第二个if，就再次递归 if (this.heap[leftIndex] &lt; this.heap[index]) { console.log('left', leftIndex, index) this.swap(leftIndex, index); this.shiftDown(leftIndex); } if (this.heap[rightIndex] &lt; this.heap[index]) { console.log('right', rightIndex, index) this.swap(rightIndex, index); this.shiftDown(rightIndex); } } 12345678910111213141516171819202122232425// 错误写法// eg： nums = [3,2,3,1,2,4,5,5,6] // 排序后为：[2, 1, 3, 3, 2, 4, 5, 5, 6 ] shiftUp(index) { // if (index === 0) return const parentIndex = this.getParent(index) // 最小堆堆化 // 此写法，while循环会漏掉， parentIndex 动态变化的那部分可以循环的内容 // 因为 parentIndex 已经将 动态变化的 index 的值给固定了 while (index &gt; 0 &amp;&amp; this.heap[parentIndex] &gt; this.heap[index]) { console.log('...&gt;') this.swap(parentIndex, index) index = parentIndex // 往上接着查 } }// 正确写法： shiftUp(index) { // 最小堆堆化 while (index &gt; 0 &amp;&amp; this.heap[this.getParent(index)] &gt; this.heap[index]) { let parentIndex = this.getParent(index) this.swap(parentIndex, index) index = parentIndex // 往上接着查 } } TODO： 概念文字待更新","link":"/601-%E5%A0%86/"},{"title":"Canvas常用方法","text":"1. 基本思路 如果位置有重叠，一般地，后面绘制的图形会覆盖前面的； 2. 画圆123456const canvas = document.querySelector(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath();ctx.arc(100, 75, 50, 0, 2 * Math.PI);ctx.stroke(); 3. 矩形12345const canvas = document.getElementById(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);ctx.rect(10, 20, 150, 100);ctx.fill();// 实心矩形 4. Math.PI**Math.PI** 表示一个圆的周长与直径的比例，约为 3.14159： 1Math.PI = 𝜋 ≈ 3.14159 5. 常用方法12ctx.fill(); // 填充形状ctx.stroke(); // 绘制形状轮廓 6. 绘制带边框的三角形注意：加边框，需要关闭绘制路径 ctx.closePath() **CanvasRenderingContext2D.closePath()** 是 Canvas 2D API 将笔点返回到当前子路径起始点的方法。它尝试从当前点到起始点绘制一条直线。如果图形已经是封闭的或者只有一个点，那么此方法不会做任何操作。 12345678910111213const canvas = document.querySelector(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath()ctx.moveTo(100, 10)ctx.lineTo(10, 100)ctx.lineTo(10, 10)ctx.fillStyle = 'pink'ctx.strokeStyle = '#ff0'ctx.closePath() // ！若要加边框，则需关闭绘制路径 ctx.fill()// stroke() 加边框，需和 closePath 配合使用ctx.stroke()","link":"/901-Canvas%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"Echarts常用样式","text":". bar 柱 渐变色 &amp; 圆角 bar 渐变色 bar 斜向渐变色 每个柱颜色不同 12345678910111213141516171819202122232425262728293031323334353637383940414243// 0, 0, 1, 1, 分别代表 右/下/左/上// 0, 0, 1, 1, 表示 斜向 渐变// 0, 0, 0, 1, 表示 由上到下 渐变const barColors = [new echarts.graphic.LinearGradient( 0, 0, 1, 1, [ {offset: 0, color: '#FF5A56'}, {offset: 1, color: '#F1961B'}, ] ), new echarts.graphic.LinearGradient( 0, 0, 1, 1, [ {offset: 0, color: '#04EFFE'}, {offset: 1, color: '#4B9EE7'}, ] ), new echarts.graphic.LinearGradient( 0, 0, 1, 1, [ {offset: 0, color: '#A661C1'}, {offset: 1, color: '#FA71CE'}, ] )]... series: [ { data: props.option.map((x, i) =&gt; x.y_axis_value), barMaxWidth: '40%', itemStyle: { // 第一个值表示顶部的左上角，第二个值表示顶部右上角 // 第三个值表示底部左下角，第四个值表示底部右下角 barBorderRadius:[4, 4, 0, 0], color: function (params){ return barColors[params.dataIndex] } }, type: 'bar', } ]... 2. echarts 官网打不开12345678910// 第一步：找到目录C:\\Windows\\System32\\drivers\\etc下的hosts文件，添加以下字段（两个都试试，哪一个可以用就用那个）：207.244.88.140 echarts.apache.org151.101.2.132 echarts.apache.org// 第二步：打开window终端刷新DNS缓存，输入以下命令：ipconfig/flushdns————————————————版权声明：本文为CSDN博主「木屋x」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34917408/article/details/124883186 3. 环形图中间显示文字 &amp; 渐变背景色12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879{ // 环形图中间添加固定的文字，与series平级 graphic: [{ type: 'text', //通过不同top值可以设置上下显示 left: 'center', top: '45%', style: { text: '标题', textAlign: 'center', fill: 'blue', //文字的颜色 width: 30, height: 30, fontSize: 16 } }], // 渐变颜色 color: [{ type: 'radial', x: 0, y: 1, r: 1, colorStops: [{ offset: 0, color: '#FF5A56' // 0% 处的颜色 }, { offset: 1, color: '#F1961B' // 100% 处的颜色 }], global: false // 缺省为 false },{ type: 'radial', x: 0, y: 1, r: 1, colorStops: [{ offset: 0, color: '#04EFFE' // 0% 处的颜色 }, { offset: 1, color: '#4B9EE7' // 100% 处的颜色 }], global: false // 缺省为 false },{ type: 'radial', x: 0, y: 1, r: 1, colorStops: [{ offset: 0, color: '#A661C1' // 0% 处的颜色 }, { offset: 1, color: '#FA71CE' // 100% 处的颜色 }], global: false // 缺省为 false }], series: [ { data: props.option.map(x =&gt; { let tem = {} tem.name = x.x_axis_value tem.value = x.y_axis_value return tem }), type: 'pie', radius: ['50%', '70%'], avoidLabelOverlap: false, label: { show: false, position: 'center' }, emphasis: { label: { show: true, fontSize: '12', fontWeight: 'bold', formatter: &quot;{c}&quot; // 中间显示值，默认显示文字 } }, labelLine: { show: false }, } ]} 4. 折线图 折线渐变12345678910111213141516171819202122series: [{type: &quot;line&quot;, itemStyle: { color: barColors[0],//折线点的颜色 lineStyle: { color: barColors[0] } }}, {type: &quot;line&quot;, itemStyle: { color: barColors[0],//折线点的颜色 lineStyle: { color: barColors[1] } }}, {type: &quot;line&quot;, itemStyle: { color: barColors[0],//折线点的颜色 lineStyle: { color: barColors[2] } }}]","link":"/902-Echarts%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"综合","slug":"综合","link":"/tags/%E7%BB%BC%E5%90%88/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Vue源码","slug":"Vue源码","link":"/tags/Vue%E6%BA%90%E7%A0%81/"},{"name":"算法与数据结构","slug":"算法与数据结构","link":"/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"}],"categories":[]}